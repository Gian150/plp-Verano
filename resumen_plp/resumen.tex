\documentclass[10pt,a4paper]{article}

\usepackage[pdftex,
pdfauthor={Gianfranco Zamboni},
pdftitle={Resumen: Paradigmas de Lenguajes de Programación},
pdfsubject={},
pdfkeywords={Resumen , Computacion, FCEyN, UBA, Paradigmas de Lenguajes de Programación, Imperativo, Funcional, Cálculo Lambda, Programación Orientada a Objetos, Objetos, Programación Lógica},
pdfproducer={Latex with hyperref},
pdfcreator={pdflatex}]{hyperref}

\usepackage{amsmath}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc} % para poder usar tildes en archivos UTF-8
\usepackage{minted}
\usepackage{a4wide} % márgenes un poco más anchos que lo usual
\usepackage[titletoc,toc,page]{appendix}

\input{comandos.tex}
\input{page.layout}

\begin{document}
\title{Resumen: Paradigmas de Lenguajes de Programación}

\date{\today}

\author{Zamboni, Gianfranco}

\maketitle
\tableofcontents

\newpage
\setcounter{page}{1}

\section{Introducción}
\paragraph{Paradigma} Marco filosófico y teórico de una escuela científica o disciplina en la que se formulan teorias, leyess y generalizaciones y se llevan a cabo experimentos que les dan sustento.

\paragraph{Lenguaje de programación} Es un lenguaje usado para comunicar instrucciones a una computadora. Estas instrucciones describen cómputos que llevará a cabo la computadora.

Un lenguaje de programación es computacionalmente completo si puede expresar todas las funciones computables.

\paragraph{Paradigma de lenguaje de programación} Marco filosófico y teórico en el que se formulan soluciones a problemas de naturaleza algorítmica. Lo entendemos como un estilo de programación en el que se escriben soluciones a problemas en términos de algoritmos.

Su ingrediente básico es el modelo de cómputo que es la visión que tiene el usuario de cómo se ejecutan sus programas.

\subsection{Aspectos del lenguaje}

\paragraph{Sintaxis} Descripción del conjunto de secuencias de símbolos considerados como programas válidos.

\subsubsection{Semántica}

Descripción del significado de instrucciones y expresiones puede ser informal (e.g. Castellano) o formal (basado en técnicas matemáticas).

\paragraph{Semántica operacional} Un programa es un mecanismo que dado un elemento del conjunto de partida, sigue una sucesión de pasos para calcular el elemento correspondiente del conjunto de llegada.

\paragraph{Semántica axiomática} Interpreta a un programa como un conjunto de propiedades verdaderas que indican los estados que puede llegar a tomar.

\paragraph{Semántica denotacional} Un programa es un valor matemático (función) que relaciona cada elemento de un conjunto de partida (expresiones que lo componen) con un único elemento de otro conjunto de llegada (significado de las expresiones).

\paragraph{Sistema de tipo} Es una herramienta que nos permite analizar código para prevenir errores comunes en tiempo de ejecución (e.g. evitar sumar booleanos, aplicar función a número incorrecto de argumentos, etc). En general, requiere anotaciones de tipo en el código fuente. 

Además sirve para que la especificación de un programa sea más clara.

Hay dos tipos de análisis de tipos:
\begin{itemize}
	\item \textbf{Estático}: Análisis de tipos en tiempo de compilación.
	\item \textbf{Dinámico}: Análisis de tipos en tiempo de ejecución.
\end{itemize}

\subsection{Paradigmas}
\subsubsection{Paradigma Imperativo}

\paragraph{Estado global} Se usan variables que representan celdas de memoria en distintos momentos del tiempo. En ellas vamos almacenando resultados intermedios del problema.

\paragraph{Asignación} Es la acción que modifica las celdas de memoria

\paragraph{Control de flujo} Es la forma que tenemos de controlar el orden y la cantidad de veces que se repite un cómputo dentro del programa. En este paradigma, la repetición de cómputos se basa en la iteración.

\vspace*{5mm}

Por lo general, los lenguajes de este paradigma son eficientes ya que el modelo de ejecución usado y la arquitectura de las computadoras (a nivel procesador) son parecidos. Sin embargo, el bajo nivel de abstracción que nos proveen hacen que, por lo general, la implementación de un problema sea difícil de entender.

\subsubsection{Paradigma Funcional}
No tiene un estado global. Un cómputo se expresa a través de la aplicación y composición de funciones y los resultados intermedios (salida de las funciones) son pasados directamente a otras funciones como argumentos. Todas las expresiones de este paradigma son tipadas y usa la recursión para repetir computos.

Ofrece un alto nivel de abstracción, es declarativo, usa una matemática elegante y se puede usar razonamiento algebraico para demostrar correctitud de programas.

\subsubsection{Paradigma Lógico}
Los programas son predicados de la lógica proposicional y la computación esta expresada a través de proof search. No existe un estado global y los resultados intermedios son pasados por unificación. La repetición se basa en la recursión.

Ofrece un alto nivel de abstracción, es muy declarativo y, al ser predicados, tiene fundamentos lógicos robustos pero su ejecución es muy lenta.

\subsubsection{Paradigma Orientado a Objetos}
La computación se realiza a través del intercambio de mensajes entre objetos. Tiene dos enfoques: basados en clases o basados en prototipos.

Ofrece alto nivel de abstracción y arquitecturas extensibles pero usa una matemática de programas compleja.


\newpage
\section{Paradigma Funcional}
Los dos aspectos fundamentales de la programación son:
\begin{itemize}
	\item Transformación de la información.
	\item Interacción con el medio (cargar datos, interfaces gráficas, etc).
\end{itemize}
La programación funcional se concentra en el primer aspecto.

\paragraph{Valor} Entidad matemática abstracta con ciertas propiedades.

\paragraph{Expresión} Secuencia de símbolos utilizada para denotar un valor. Hay dos tipos de expresiones:
\begin{itemize}
	\item \textbf{Atómicas ó formas formales}: Son las expresiones más simples y denotan un valor.
	\item \textbf{Compuestas}: Expresiones que se construyen combinando otras expresiones.
\end{itemize}

Puede haber expresiones incorrectas (mal formadas) debido a errores sintácticos (expresiones mal escritas) o a errores de tipo (expresiones que denotan operaciones sobre tipos incorrectos).

En funcional, computar significa tomar una expresión y reducirla hasta que sea atómica.

\paragraph{Transparencia referencial} El valor que denota una expresión solo depende de los símbolos que la constituyen. Esto nos permite indicar. Esto nos permite hacer uso de un programa sin considerar la necesidad de considerar los detalles de su ejecución y nos permite demostrar propiedades usando las propiedades de las subexpresiones y métodos  de deducción lógica.

\subsection{Tipos}
Son una forma de particionar el universo de valores de acuerdo a ciertas propiedades. Hay:
\begin{itemize}
	\item \textbf{Tipos básicos} (Int, Bool, Float) ó primitivos que son los que ya vienen definidos en el lenguaje por literales y representan valores 
	\item \textbf{Tipos compuestos} (pares, listas) que son aquellos que se definen a partir de otros tipos.
\end{itemize}

Cada tipo de dato tiene asociado operaciones que no tienen significado para otros tipos.

A toda expresión bien formada se le puede asignar un tipo que sólo depende los componentes de la expresión (strong-typing). Dada una expresión, se puede deducir su tipo a partir de su constitución.

\subsubsection{Notación}  
\mint{haskell}{e :: A } se lee “la expresión e tiene tipo A” y significa que el valor denotado por e pertenece al conjunto de valores denotado por A.

\subsubsection{Propiedades deseables de un lenguaje funcional}
Se busca que un lenguaje le asigne un tipo de manera automática al mayor número posible de expresiones con sentido y que no le asigne ningún tipo al mayor número posible de expresiones mal formadas. Además, se busca que el tipo de la expresión se mantenga si es reducida.

Otra cosa a tener en cuenta, es que los tipos ofrecidos por el lenguaje deben ser descriptivos y razonablemente sencillos de leer.

\paragraph{Inferencia de tipos} Dada una expresión e determinar si tiene tipo o no y, si lo tiene, cuál es ese tipo según las reglas.

\paragraph{Chequeo de tipos} Dada una expresión e y un tipo A, determinar si e :: A o no.

\subsection{Tipo Función}
Un programa en el paradigma funcional es una función descripta por un conjunto de ecuaciones (expresiones) que definen uno o más valores. Estas ecuaciones son evaluadas (reducidas) hasta llegar a una expresión atómica que nos indique el valor de las mismas.

\paragraph{Funciones} Las funciones son valores especiales que representan transformación de datos. En haskell el tipo de una función se escribe: $->$. Las funciones se aplican a elementos de un conjunto de entrada definido por el tipo de entrada de la función y devuelve un elemento del tipo de salida.

Al ser valores, las funciones pueden ser argumentos y resultados de otras funciones, pueden almacenarse y pueden ser estructuras de datos.

\paragraph{Funciones de alto orden} Son funciones que manipulan otras funciones.

\paragraph{Lenguaje Funcional Puro} Lenguaje de expresiones con transparencia referencial y funciones como valores, cuyo modelo de cómputo es la reducción realizada mediante el reemplazo de iguales por iguales.

\paragraph{Polimorfismo paramétrico} Cuando una función tiene un parámetro que puede ser instanciado de diferentes maneras en diferentes usos. Esta propiedad se da dentro de los sistemas de tipos.

Dada una expresión que puede ser tipada de infinitas maneras, el sistema puede asignarle un tipo que sea más general que todos ellos, y tal que en cada uso pueda transformarse en uno particular.

Hay funciones que a pesar de poseer polimorfismo paramétrico, no aceptan cualquier clase de tipo, sino que requieren que los tipos con las que son llamadas tengan ciertas propiedades. Por ejemplo, que tengan relaciones de igualdad (Eq), relación de order (Ord), que se comporten como números (Num) o que puedan ser mostrados en pantalla (Show)

\subsubsection{Evaluación}
Por lo general, dependiendo del orden de evaluación del lenguaje, el tipo de evaluación se  clasifica en:

\paragraph{Evaluación Estricta} Si una parte de una expresión se indefine, entonces la expresión se indefine. La evaluación eager, en la que un en lenguaje computa una expresión apenas es definida, es de este tipo. 

\paragraph{Evaluación no Estricta} Puede pasar que una expresión esté definida a pesar de que alguna de sus partes se haya indefinido. La evaluación lazy, en la que un lenguaje solo computa una expresión cuando de esta depende el valor de otra expresión, es de este tipo.

Haskell usa evaluación lazy de izquierda a derecha, resolviendo primero las partes más externas de la expresión y luego, si es necesario, sus partes.

\paragraph{Currificación} Correspondencia entre cada función de múltiples parámetros y una de alto orden que retorna una función intermedia que completa el trabajo.
Por cada \textit{f} definida como:
\begin{centrado}
	\begin{minted}{haskell}
f :: (a,b) -> c
f (x,y) = e
	\end{minted}
\end{centrado} 
existe un función \textit{f'} tal que se puede escribir:
\begin{centrado}
	\begin{minted}{haskell}
f' :: a -> (b -> c)
(f' x) y = e
	\end{minted}
\end{centrado} 

La currificación nos da mayor expresividad y la posibilidad de realizar evaluación parcial. Además, nos permite tratar el código de manera más modular al momento de inferir tipos y transformar programas.

\paragraph{Evaluación parcial} Se evalúan las funciones parcialmente, lo que nos permite llamarlas con menos parámetros de los que necesitan. Esto nos devuelve una función con las expresiones asociadas a los valores pasados como parámetros y que toma como parámetros los parámetros faltantes de la función original.

\subsection{Inducción/Recursion}

La inducción es un mecanismo que nos permite definir conjuntos infinitos, probar propiedades sobre sus elementos y definir funciones recursivas sobre ellos con garantía de terminación.

\paragraph{Principio de extensionalidad:} Dadas dos expresiones A y B, si A y B denotan el mismo valor, entonces A puede ser remplazada por B y B por A sin que esto afecte al resultado de una equación.

\subsubsection{Inducción estructural}
Una definición inductiva de un conjunto $\rel$ consiste en dar condiciones de dos tipos:
\begin{itemize}
	\item reglas base ($z\in\rel$) que afirman que algún elemento simple $x$ pertenece a $\rel$
	\item reglas inductivas ($y_1\in\rel,\dots,y_n\in\rel\Rightarrow y\in\rel$) que afirman que un elemento compuesto $y$ pertenece a
	$\rel$ siempre que sus partes $y_1,\dots,y_n$ pertenezcan a $\rel$
	(e $y$ no satisface otra regla de las dadas)
\end{itemize}

y pedir que $\rel$ sea el menor conjunto (en sentido de
la inclusión) que satisfaga todas las reglas dadas.

\subsubsection{Funciones recursivas}
Sea $S$ un conjunto inductivo, y $T$ uno cualquiera. Una definición recursiva estructural de una función \texttt{f :: S -> T} es una definición de la siguiente forma:
\begin{itemize}
	\item Por cada elemento base \texttt{z}, el valor de \texttt{(f z)} se da directamente usando valores previamente definidos
	\item Por cada elemento inductivo \texttt{y}, con partes inductivas \texttt{y$_1$}, ..., \texttt{y$_n$}, el valor de \texttt{(f y)} se da usando valores previamente definidos y los valores \texttt{(f y$_1$)}, ..., \texttt{(f y$_n$)}.
\end{itemize}

\subsubsection{Principio de inducción}
Sea $S$ un conjunto inductivo, y sea $P$ una propiedad sobre los elementos de S. Si se cumple que:
\begin{itemize}
	\item para cada elemento $z\in S$ tal que $z$ cumple con una regla base, $P(z)$ es verdadero, y
	\item para cada elemento $y\in S$ construído en una regla inductiva utilizando los elementos \\ $y_1, ..., y_n$, si $P(y_1 ), ..., P(y_n)$ son verdaderos entonces $P(y)$ lo es
	
\end{itemize}

entonces $P(x)$ se cumple para todos los $x\in S$.

\subsection{Parametrización}
Dado un conjunto de funciones que se comportan de la misma manera buscamos encontrar alguna forma de crear una función que las genere automáticamente. 

\paragraph{Esquema de funciones} Dado un conjunto de funciones "parecidas", el esquema de estas funciones son los que no permiten parametrizar correctamente alguno de los parámetros.

La parametrización nos permitirá crear definiciones más concisas y modulares, reutilizar código y demostrar propiedades generales de manera más fácil.

\subsection{Tipos algebraicos}

\subsubsection{Definición de tipos}
Hay dos formas de definir un tipo de dato:
\begin{itemize}
	\item \textbf{De manera algebraica:} Establecemos qué \textit{forma} tendrá cada \textit{elemento} y damos un mecanismo único para inspeccionar cada elemento.
	\item \textbf{De manera abstracta:} Determinamos cuales serán las \textit{operaciones} que manipularán los elementos, \textbf{SIN} decir cuál será la forma exacta del tipo ni de las operaciones que definimos.
\end{itemize}

\subsubsection{Tipos algebraicos en Haskell}
Los definimos mediante \textbf{constantes} llamadas \textit{constructores} cuyos nombres comienzan con mayúscula. Los constructores no tienen asociada una regla de reducción y pueden tener argumentos.

Para implementarlos en Haskell, usamos la clausula \texttt{data} que introduce un nuevo tipo algebraico, los nombres su constructores y sus argumentos.

\textbf{Ejemplos:}
\begin{centrado}
	\begin{minted}{haskell}
data Sensacion = Frio | Calor
data Shape = Circle Float | Rect Float Float
	\end{minted}
\end{centrado}

Los tipos algebraicos pueden tener argumentos. Esto nos permite definir tipos que contienen al conjunto de elementos de otro tipo más los elementos del tipo que se están definiendo.

\textbf{Ejemplo:}
\begin{centrado}
	\begin{minted}{haskell}
data Maybe = Nothing | Just a
	\end{minted}
\end{centrado}
\texttt{Maybe} tiene todos los elementos del tipo a con \texttt{Just} adelante más el elemento \textit{Nothing}

\vspace*{5mm}

Son considerados tipos algebraicos porque:
\begin{itemize}
	\item toda combinación válida de constructores y valores es elemento del tipo algebraico (y solo ellas lo son)
	\item y porque dos elementos de un tipo algebraico son iguales si y solo si están construidos utilizando los mismos constructores aplicados a los mismos valores.
\end{itemize}
Al principio de esta sección, dijimos que además de establecer la forma que tiene el tipo, debemos dar un mecanismo único de inspección. En Haskell, este mecanismo es el \textbf{Pattern Matching}.


\subsubsection{Pattern Matching}
El pattern matching es la búsqueda de patrones especiales (en nuestro caso, los constructores de nuestro tipo) dentro de una expresion en el lado izquierdo de una ecuación que, si tiene éxito, nos permita inspeccionar el valor de la misma.

Si el pattern matching resulta exitoso, entonces ligas las variables del patrón.

\subsubsection{Tipos especiales}
\paragraph{Tupla} Este tipo es un tipo algebraico con sintaxis especial. Una tupla es un estructura que posee varios elementos de distintos tipos. Por ejemplo: \texttt{(Float,Int)} es una tupla cuyo primer elemento es un \texttt{Float} y tiene como segundo elemento a un \texttt{Int}.

\paragraph{Maybe} El tipo \texttt{Maybe}, definido en el último ejemplo, nos permite expresar la posibilidad de que el resultado sea erróneo, sin necesidad de usar casos especiales. De esta forma, logramos evitar el uso de $\bot$ hasta que el programador lo decida, permitiendo controlar errores.

\paragraph{Either} El \texttt{Either} representa la union disjunta de dos conjuntos (los elementos de uno se identifican con \texttt{Left} y los del otro con \texttt{Right}. Sirve para mantener el tipado fuerte y poder devolver elementos de distintos tipos o para representar el origen de un valor.
\begin{centrado}
	\begin{minted}{haskell}
data Either = Left a | Right b
	\end{minted}
\end{centrado}

\subsubsection{Expresividad}
Los tipos algebraicos no pueden representar cualquier cosa, por ejemplo, los números racionales son pares de enteros (numerador, denominador) cuya igualdad puede no depender de los valores con los que fueron construidos o incluso pueden llegar a no ser validos. Esto es así porque no todo par de enteros es un número racional, por ejemplo el (1,0). 

Además recordemos que la igualdad de dos elementos de un tipo algebraico solo se da si estos fueron construidos exactamente de la misma forma. Si seguimos con el ejemplo de los racionales, sabemos que hay racionales iguales con distinto numerador y denominador como el (4,2) y el (2,1), sin embargo estos dos pares no podrian serr nunca iguales si fuesen tomados como un tipo algebraico.

\subsubsection{Clases de tipos algebraicos}

\paragraph{Enumerativos} Solo constructores sin argumentos.

\paragraph{Productos} Un único constructor con varios argumentos.

\paragraph{Sumas} Varios constructores con argumentos.

\paragraph{Recursivos} Utilizan el tipo definido como argumento.

\subsection{Tipos algebraicos recursivos}
Un tipo algebraico recursivo tiene al menos menos uno de los constructores con el tipo que se define como argumetno y es la concreción, en Haskell, de un conjunto definido inductivamente.

Cada constructor define un caso de una definición inductiva de un conjunto. Si tiene al tipo definiod como argumento, entonces es un caso inductivo, si no, es un caso base.

En estos caso, el pattern matching nos da una forma de realizar analizar los casos y de acceder a los elementos inductivos que forman a un elemento dado. Por esta razón, se pueden definir funciones recursivas.

A estos tipos, les damos un significado a través de funciones definidas recursivamente. Estas funciones, manipulan simbolicamente al tipo. Sin embargo, estas manipulaciones por si solas no tienen un significado, sino que el significado se lo dan las propiedades que dichas manipulaciones deben cumplir.

\paragraph{Enteros} Notación unaria para expresar tipos enteros.
\begin{centrado}
	\begin{minted}[breaklines]{haskell}
data N = Z | S N
	\end{minted}
\end{centrado}

\paragraph{Listas} Definición equivalente a las listas de haskell
\begin{centrado}
	\begin{minted}[breaklines]{haskell}
data List a = Nil | Cons a (List a)
	\end{minted}
\end{centrado}

\paragraph{Árboles}
Un árbol es un tipo algebraico tal que al menos un elemento compuesto tiene dos componentes inductivas.

\begin{centrado}
	\begin{minted}[breaklines]{haskell}
data Arbol a = Hoja a | Nodo a (Arbol a) (Arbol a)
	\end{minted}
\end{centrado}

\subsection{Esquemas de recursión} \label{sec:funcional.sub:esquemas_recursion}
Cuando tenemos un conjunto de funciones que manipulan ciertas estructuras de manera similar, podemos abstraer este comportamiento en funciones de alto orden que nos facilitarán su escritura.

A continuación, veremos unos ejemplos de esquemas sobre listas: 
\paragraph{Map}
Dada una lista \textit{l}, aplica una función \textit{f} a cada elemento de \textit{l}.
\begin{centrado}
	\begin{minted}{haskell}
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = (f x) : (map f xs)
	\end{minted}
\end{centrado} 

\textbf{Ejemplo:}
\begin{centrado}
	\begin{minted}{haskell}
doble x = x + x
dobleL = map doble  
	\end{minted}
\end{centrado} 

\textit{dobleL} calcula el doble de cada elemento de una lista.

\paragraph{Filter}
Dada una lista \textit{l} y un predicado \textit{p}, selecciona todos los elementos de \textit{l} que cumplen \textit{p}.

\begin{centrado}
	\begin{minted}{haskell}
filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter p (x:xs) | (p x)     = x : (filter p xs)
                | otherwise = filter p xs  
	\end{minted}
\end{centrado}

\textbf{Ejemplo}
\begin{centrado}
	\begin{minted}{haskell}
masQueCero = filter (>0)
	\end{minted}
\end{centrado}

\textit{masQueCero} se queda con todos los elementos mayores de una lista

\paragraph{Fold}
La función foldr es la función que expresa el patrón de recursión estructural sobre listas como función de alto orden. Dada una lista \textit{l} y una función \textit{f} que denota un valor que depende de todos los elementos de la lista \textit{l} y un valor inicial \textit{z}, aplica y combina las soluciones parciales obtenidas por \textit{f} de manera "iterativa". 
Hay dos tipos de fold: foldr (acumula desde la derecha) y foldl (acumula desde la izquierda).

Podemos definir map y filter con esta función
\begin{centrado}
	\begin{minted}{haskell}
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr _ z [] = z
foldr f z (x:xs) = f x (foldr f z xs)
		
		
foldl :: (a -> b) -> b -> [a] -> b
foldl _ z [] = z
foldl f z (x:xs) = foldl f (f z x) xs
\end{minted}
\end{centrado}

\textbf{Ejemplos}

\begin{centrado}
	\begin{minted}{haskell}
map f = foldr (\x rec -> (f x): rec) []
filter p = foldr (\x rec -> if (p x) then x:rec else rec) []
	\end{minted}
\end{centrado}


\paragraph{Recursión primitiva}
Recordemos de Logica y Computabilidad: una función h es recursiva primitiva si \textit{h} es de la forma:

\begin{align}
		h(x_1,\dots,x_n,0) &= f(x_1,\dots,x_n) \\
		h(x_1,\dots,x_n,t+1) &= g(h(x_1,\dots,x_n, t),x_1,\dots, x_n, t) \\
\end{align}

Es decir, el caso recursivo de \textit{h} no solo depende de la descomposición de sus parámetros, sino que, además, depende de sus parámetros.

En Haskell, podemos definir una función que dada una lista \texttt{l}, un caso base \texttt{z} y un caso recursivo primitivo \texttt{f}, aplique la definición de \texttt{z} y \texttt{f} a la lista:
\begin{centrado}
	\begin{minted}{haskell}
recr :: b -> (a -> [a] -> b -> b) -> [a] -> b
recr z _ []= z
recr z f (x:xs) = f x xs (recr z f xs)
	\end{minted}
\end{centrado}

En listas, este tipo de esquemas es dificil de ver. Como ejemplo, escibimos la función \texttt{insertar} de una lista con recursión primitiva:
\begin{centrado}
	\begin{minted}{haskell}
-- Insert con pattern matching
insert :: a -> [a] -> [a]
insert x [] = [x]
insert x (y:ys) = if x<y then (x:y:ys) else (y:insert x ys)

-- Insert con recursión primitiva
insert x = recr [x] (\y ys zs -> if x<y then (x:y:ys) else (y:zs))
	\end{minted}
\end{centrado}

En el segundo caso, insert es una función que agrega el elemento \texttt{x} a una lista \texttt{xs} que se le pase como parámetro.

\paragraph{Divide \& Conquer}
La clásica técnica algorítmica recursiva definida de manera funcional; En este caso, DivideConquer es un tipo de función, es decir define una familia de funciones, que toman como parámetro 4 funciones y un elemento de tipo \texttt{a} y devuelve un elemento de tipo \texttt{b}:
\begin{centrado}
	\begin{minted}[breaklines]{haskell}
type DivideConquer a b  = (a -> Bool) -> (a -> b) -> (a -> [a]) -> 
                          ([b] -> b) -> a -> b                         
\end{minted}
\end{centrado}
Las funciones que toma como parámetro son:
\begin{itemize}
	\item \texttt{esTrivial :: a -> Bool} que devuelve verdadero si elemento de tipo \texttt{a} es el caso base del problema.
	\item \texttt{resolver :: a -> b} que resuelve el problema cuando el elemento de tipo \texttt{a} es el caso trivial
	\item \texttt{repartir :: a -> [a]} que divide al elemento de tipo \texttt{a} en la cantidad de subproblemas necesarios para resolver el problema.
	\item \texttt{combinar :: [b] -> b} que resuelve todos los subproblemas obtenidos por \texttt{repartir} y combina sus soluciones para obtener el resultado final.
\end{itemize}

\textbf{Ejemplo}

Vamos a definir el Divde \& Conquer para listas:
\begin{centrado}
	\begin{minted}[breaklines]{haskell}
divideConquerListas :: DivideConquer [a] b
-- Esto significa que DivideConquerLista es de tipo 
-- ([a] -> Bool) -> ([a] -> b) -> ([a] -> [[a]]) -> ([b] -> b)
-- -> [a] -> b

divideConquerListas esTrivial resolver repartir combinar l =
	if (esTrivial l) then resolver l
	else combinar (map dc (repartir l))
where dc = divideConquerListas esTrivial resolver repartir combinar
                        
	\end{minted}
\end{centrado}


\paragraph{Otros esquemas de recursión} Los esquemas de recursión que nombramos, no son los únicos que existen y además, pueden ser definidos para otros tipos recursivos, no solo para listas. Al final

\subsubsection{La función fold y como definirla}
Todo tipo algebraico tiene asociado un patrón de inducción estructural. En particular, dado un tipo algebraico recursivo \texttt{T}, podemos definir la función \texttt{foldrT:: * -> a} donde * son los parámetros de la función. A continuación damos algunas propiedades que debe cumplir para asegurarnos de la definimos correctamente:
\begin{itemize}
	\item Por cada constructor recursivo debe tomar una función que tome como parámetros a cada elemento del constructor que no sea del tipo \texttt{T} y un parámetro de tipo \texttt{a} por cada elemento del tipo \texttt{T}  del constructor. Esta función devuelve un elemento del tipo \texttt{a} y es la que resolverá recursivamente el caso planteado usando la segunda clase de parámetros.
	\item Por cada constructor base de \texttt{T} debe tomar un parámetro de tipo \text{a} que será el elemento devuelto por la función si cae en alguno de dichos casos.
	\item Por último, si la función está bien implementada, si remplazamos cada parámetro por el contructor correspondiente que tiene asignado, la función resultante debería ser la función identidad del tipo \texttt{T}.
\end{itemize}


Al momento de definir \texttt{fold} ayuda mucho plantear el esquema de recursión del tipo.

\appendix

\section{Programación funcional en Haskell}
\paragraph{Tipos elementales}
\begin{centrado}
	\begin{minted}{haskell}
1               -- Int          Enteros
'a'             -- Char         Carácteres
1.2             -- Float        Números de punto flotante
True            -- Bool         Booleanos
[1,2,3]         -- [Int]        Listas
(1, True)       -- (Int, Bool)  Tuplas, pares
length          -- [a] -> Int   Funciones
length [1,2,3]  -- Int          Expresiones
\x -> x         -- a -> a       Funciones anónimas
	\end{minted}
\end{centrado}

\paragraph{Guardas}
\begin{centrado}
	\begin{minted}{haskell}
signo n | n >= 0    = True
        | otherwise = False
	\end{minted}
\end{centrado}

\paragraph{Patter Matching}
\begin{centrado}
	\begin{minted}{haskell}
longitud [] = 0
longitud (x:xs) = 1 + (longitud xs)
	\end{minted}
\end{centrado}

\paragraph{Polimorfismo parámetrico}
\begin{centrado}
	\begin{minted}{haskell}
todosIguales :: Eq a => [a] -> Bool
todosIguales [] = True
todosIguales [x] = True
todosIguales (x:y:xs) = x == y && todosIguales(y:xs)
	\end{minted}
\end{centrado}

\paragraph{Clases de tipo}
\begin{centrado}
	\begin{minted}{haskell}
Eq a    -- Tipos con comparación de igualdad
Num a   -- Tipos que se comportan como los números
Ord a   -- Tipos orden
Show a  -- Tipos que pueden ser representados como strings
	\end{minted}
\end{centrado}

\paragraph{Definición de listas}
\begin{centrado}
	\begin{minted}[breaklines]{haskell}
[1,2,3,4,5]                 -- Por extensión
[1 .. 4]                    -- Secuencias aritméticas
[ x | x <- [1..], esPar x ] -- Por compresión

-- Las listas pueden ser infinitas, solo hay que tener cuidado cuando las usamos. Ejemplo de lista infinita:
	
infinitosUnos = 1 : infinitosUnos
	\end{minted}
\end{centrado}

\paragraph{Funciones de alto orden}
\begin{centrado}
	\begin{minted}[breaklines]{haskell}
mejorSegun :: (a -> a -> Bool) -> [a] -> a
mejorSegun _ [x] = x
mejorSegun f (x : xs) | f x (mejorSegun f xs) = x
                      | otherwise = mejorSegun f xs
\end{minted}
\end{centrado}

\subsection{Otros tipos útiles}
\paragraph{Formula}
\begin{centrado}
	\begin{minted}[breaklines]{haskell}
data Formula = Proposicion String | No Formula 
                                  | Y Formula Formula
                                  | O Formula Formula
                                  | Imp Formula Formula
                                  
foldFormula :: (String -> a) -> (Formula -> a) -> 
               (Formula -> Formula -> a) -> (Formula -> Formula -> a) 
               -> (Formula -> Formula -> a) -> Formula -> a
foldFormula fp fn fy fo fImp form = case form of :
		Proposicion s -> fp s
		No sf -> fn (rec sf)
		Y sf1 sf2 -> fy (rec sf1) (rec sf2)
		O sf1 sf2 -> fo (rec sf1) (rec sf2)
		Impl sf1 sf2 -> fImpl (rec sf1) (rec sf2)
	where rec = foldForm fp fn fy fo fImp
	\end{minted}
	\end{centrado}

\paragraph{Rosetree}
\begin{centrado}
	\begin{minted}[breaklines]{haskell}
data Rosetree = Rose a [Rosetree]
-- Hay varias formas de definir el fold para esta estructura
foldRose :: (a -> [b] -> b) -> Rosetree a -> b
foldRose f ( Rose x l ) = f x ( map ( foldRose f ) l )
	
foldRose2 :: ( a -> c -> b) -> ( b -> c -> c ) -> c 
            -> Rosetree a -> b
foldRose2 g f z (Rose x l) = 
          g x ( foldr f z ( map ( foldRose g f z ) l ) )
		

	\end{minted}
	
	
\end{centrado}

\end{document}