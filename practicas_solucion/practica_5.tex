\documentclass[10pt,a4paper]{article}
\input{header}

\setcounter{section}{5}

\begin{document}
\title{PLP - Práctica 5: Programación Orientada a Objetos}
%
\date{\today}
%
\author{Zamboni, Gianfranco}
%
\maketitle
\setcounter{page}{1}
%
\section*{Programación en JS}
\subsection{Ejercicio 1}
\paragraph{a)}
\begin{centrado}
\begin{minted}[breaklines, tabsize=2]{javascript}
c1i = {
    r: 1,
    i: 1
}
\end{minted}
\end{centrado}
\paragraph{b)}
\begin{centrado}
\begin{minted}[breaklines, tabsize=2]{javascript}
c1i.sumar = function(complejo){
    this.r += complejo.r
    this.i += complejo.i
}
\end{minted}
\end{centrado}
\paragraph{c)}
\begin{centrado}
\begin{minted}[breaklines, tabsize=2]{javascript}
c1i.sumar = function(complejo){
    return {
        r: this.r + complejo.r
        i: this.i + complejo.i
    }
}
\end{minted}
\end{centrado}

\paragraph{d)} Asi como están implementadas, funciona.
\paragraph{e)}
\begin{centrado}
\begin{minted}[breaklines, tabsize=2]{javascript}
let c = c1i.sumar(c1i)

c1i.sumar = function(complejo){
    return {
        r: this.r - complejo.r
        i: this.i - complejo.i
    }
}
\end{minted}
\end{centrado}
\texttt{c1i} no tiene definida la función restar, por lo que \texttt{c1i.restar(\_)} nos dará un error.

\paragraph{f)}
\begin{centrado}
\begin{minted}[breaklines, tabsize=2]{javascript}
c1i.mostrar = function () {
    if(this.i != 1){
        console.log(this.r+" "+this.i+"i");
    }else{
        console.log(this.r+" "+"i");
    }
}
\end{minted}
\end{centrado}
En este caso, \texttt{c} no podrá mostrar sus elementos, ya que cuando lo creamos \texttt{c1i} como un nuevo objeto que no está relacionado con \texttt{c}.

\subsection{Ejercicio 2}
\begin{centrado}
\begin{minted}[breaklines, tabsize=2]{javascript}
// a)
let t = {}
let f = {}

t.ite = function(a,b) {
    return a;
}

f.ite = function(a,b) {
    return b;
}

// b)
t.mostrar = function() {
    return "Verdadero";
}

f.mostrar = function(){
    return "Falso";
}

// c)
t.not = function(){
    return f;
}

f.not = function(){
    return t;
}

t.and = function(otroValor) {
    return otroValor;
}

f.and = function(element) {
    return this;
}

\end{minted}
\end{centrado}

\subsection{Ejercicio 3}
\begin{centrado}
\begin{minted}[breaklines, tabsize=2]{javascript}
// a)
let Cero = {};

Cero.esCero = function(){
    return true;
};

Cero.succ = function(){
    return new Sucesor(this);
}


function Sucesor(pred){
    this.predecesor = pred;
};

Sucesor.prototype.__proto__ = Cero;   

Sucesor.prototype.pred = function(){
    return this.predecesor;
}

// b)
Cero.toNumber = function(){
    return 0;
}

Sucesor.prototype.toNumber = function(){
    return this.pred().toNumber() + 1;
}

// c)
Cero.for = function(f){}

Sucesor.prototype.for = function(f){
    this.pred().for(f);
    f.eval(this);
}
\end{minted}
\end{centrado}

\newpage
\subsection{Ejercicio 4}
\paragraph{a)}
\begin{centrado}
\begin{minted}[breaklines, tabsize=2]{javascript}
var Punto = {};
Punto.new = function(x,y) {
    var p = {};
    p.x=x;
    p.y=y;
    p.mostrar = function () {
        return Punto.mostrar(this);
    }
    return p;
}

Punto.mostrar = function(o) {
    return `Punto(${o.x},${o.y})`    
}

\end{minted}
\end{centrado}
\paragraph{b)}
\begin{centrado}
\begin{minted}[breaklines, tabsize=2]{javascript}
var PuntoColoreado = {};
PuntoColoreado.new = function(x,y){
    var p = Punto.new(x,y);
    p.color = "rojo";
    p.mostrar = function(){ 
        return PuntoColoreado.mostrar(this);
    };
    return p;
};

PuntoColoreado.mostrar = function(o) { 
    return Punto.mostrar(o);
};
\end{minted}
\end{centrado}

\paragraph{c)}
\begin{centrado}
\begin{minted}[breaklines, tabsize=2]{javascript}
var PuntoColoreado = {};
PuntoColoreado.cons = function (x,y,color) {
    var nuevo = this.new(x,y);
    nuevo.color = color;
    return nuevo;
}
\end{minted}
\end{centrado}

\paragraph{d)}
\begin{centrado}
\begin{minted}[breaklines, tabsize=2]{javascript}
\begin{lstlisting}
    var p1 = Punto.neww(1 ,2);
    var pc1 = PuntoColoreado.neww(1 ,2);
    Punto.mover = "me muevo";
    var p2 = Punto.neww(1 ,2);
    var pc2 = PuntoColoreado.neww(1 ,2);

    console.log(p1.mover);
    console.log(pc1.mover);
    console.log(p2.mover);
    console.log(pc2.mover);

   // Se pude observar que todos los objetos se pueden mover, porque los puntos coloreados tienen una referencia a los puntos, por lo tanto si se agrga una funcionalidad al punto, tanbién se agregará al punto coloreado.
\end{minted}
\end{centrado}
  
\subsection{Ejercicio 5}
\begin{centrado}
\begin{minted}[breaklines, tabsize=2]{javascript}
function Punto(x, y){
    this.x = x;
    this.y = y;
}

Punto.prototype.mostrar = function(){
    return `Punto(${this.x},${this.y})`
}

function PuntoColoreado(x,y, color) {
    this.x = x
    this.y = y
    this.color = color
}
PuntoColoreado.prototype.__proto__ = Punto.prototype

Punto.prototype.moverX = function(x){
    this.x += x
}
\end{minted}
\end{centrado}

\subsection{Ejercicio 6}
\paragraph{a)} En el primer caso, una vez creado el objeto a, el prototipo de este objeto ya queda fijo. Cuando realizamos la asignación \mintinline{javascript}{C1.prototype = C2.prototype;}, la variable \texttt{C1.prototype} deje de referenciar al objeto prototipo de \texttt{a} y referencie al objeto que referencia \texttt{C2.prototype}. Provocando, esto, que el constructor \mintinline{javascript}{C1()} lo asigne como prototipo de \texttt{b}.

Entonces \texttt{a} sigue teniendo el mismo prototipo y \texttt{b} tiene como prototipo a \texttt{C2} por lo que los resultados de evaluar sus atributos son:

\begin{centrado}
\begin{minted}[breaklines, tabsize=2]{javascript}
a.g // 'Hola'
b.g // 'Mundo'
\end{minted}
\end{centrado}

\paragraph{b)} En el segundo caso, estamos modificando el atributo \texttt{g} del objeto que es referenciado por \texttt{C1.prototype}. La asignación \mintinline{javascript}{C1.prototype.g = C2.prototype.g;} remplaza la función \texttt{g} original de \texttt{C1.prototype} por la función \texttt{g} de \texttt{C2.prototype}.
Entonces, las soluciones quedan:
\begin{centrado}
\begin{minted}[breaklines]{javascript}
a.g // 'Mundo'
b.g // 'Mundo'
\end{minted}
\end{centrado}

\subsection{Ejercicio 7}
\paragraph{a)} \texttt{a} será un array con todas las claves de \texttt{o1} y \texttt{b} será el array con todos sus valores en el mismo orden, es decir, si en \texttt{a[0]} se encuentra la clave \mintinline{javascript}{'a'}, entonces en \texttt{b[0}] se encuentra el valor \mintinline{javascript}{1}.

\paragraph{b)}
\begin{centrado}
\begin{minted}[breaklines, tabsize=2]{javascript}
function extender(o1, o2) {
    for(let key in o1) {
        if(o2[key] == undefined){
            o2[key] = o1[key];
        }
    }
}
\end{minted}
\end{centrado}

\paragraph{c)} Hay que hacer dos modificaciones: Definir en \texttt{B} el método y eliminarlo de A.
\begin{centrado}
\begin{minted}[breaklines, tabsize=2]{javascript}
B.presentar = A.presentar
delete A.presentar
\end{minted}
\end{centrado}

\paragraph{d)} Es lo mismo que en el anterior, pero usando \texttt{prototype}.
\begin{centrado}
\begin{minted}[breaklines, tabsize=2]{javascript}
B7d.prototype.presentar = A7d.prototype.presentar
delete A7d.prototype.presentar
\end{minted}
\end{centrado}

\section*{Cálculo de Objetos}

\subsection{Ejercicio 8}
\subsubsection{}
Representan al mismo objeto porque responden a los mismos mensajes. la unica variacion que se observa es el renombre del parametro this entre x,z,v.
\subsubsection{}
Representan a distintos objetos porque responden a los distintos mensajes.
\subsection{Ejercicio 9}
$o =_{def} [arg = \varsigma(x)x; val = \varsigma(x)x.arg].$
\subsubsection{o.val}
\vspace*{5mm}
	\begin{center}
		\begin{scprooftree}
		    
		    \AxiomC{}
		    \RightLabel{[Obj]}
		    \UnaryInfC{$o \rightarrow o$}
		    
			    \AxiomC{}
		    \RightLabel{[Obj]}
		    \UnaryInfC{$o \rightarrow o$}

			    \AxiomC{}
		    \RightLabel{[Obj]}
		    \UnaryInfC{$(x)\{x \leftarrow o\} \rightarrow o$}
		    
	    \RightLabel{[Sel]}
	    \BinaryInfC{$(x.arg)\{x \leftarrow o\} \rightarrow o$}
		    
\RightLabel{[Sel]}
\BinaryInfC{$o.val \rightarrow o$}
		\end{scprooftree}    
	\end{center}
\subsubsection{\blue{o.val.arg}}
\vspace*{5mm}
	\begin{center}
		\begin{scprooftree}
		
		    \AxiomC{}
		    \RightLabel{[Obj]}
		    \UnaryInfC{$o \rightarrow o$}
		    \RightLabel{[Obj]}
		    \UnaryInfC{$o.val \rightarrow o$}
    		    \AxiomC{}
    		    \RightLabel{[Obj]}
    		    \UnaryInfC{$o \rightarrow o$}
    		    \RightLabel{[Obj]}
    		    \UnaryInfC{$o.val \rightarrow o$}
            		\AxiomC{}
        		    \RightLabel{[Obj]}
        		    \UnaryInfC{$o \rightarrow o$}
        
        		    \AxiomC{}
        		    \RightLabel{[Obj]}
        		    \UnaryInfC{$(x)\{x \leftarrow o\} \rightarrow o$}
        	    \RightLabel{[Sel]}
    		    \BinaryInfC{$(x.arg)\{x \leftarrow o\} \rightarrow o$}
		    \RightLabel{[Sel]}
		    \BinaryInfC{$(x)\{x \leftarrow o.val\} \rightarrow o$}
		    \RightLabel{[Sel]}
        \BinaryInfC{$o.val.arg \rightarrow o$}
		\end{scprooftree}    
	\end{center}

\subsubsection{$(o.arg \Leftarrow \Sigma(z)0).val$}
\subsection{Ejercicio 10}
\subsection{Ejercicio 11}
\subsubsection{Objetos true y false:}
$
true = [not: \varsigma(x)false,if: \varsigma(x)\lambda(y)\lambda(z)y,ifnot: \varsigma(x)\lambda(y)\lambda(z)z]
$ \\
$
false = [not: \varsigma(x)true,if: \varsigma(x)\lambda(y)\lambda(z)z,ifnot: \varsigma(x)\lambda(y)\lambda(z)y]
$
\subsubsection{}
$
true = [not: \varsigma(x)false,if: \varsigma(x)\lambda(y)\lambda(z)y]
$ \\
$
false = [not: \varsigma(x)true,if: \varsigma(x)\lambda(y)\lambda(z)z]
$
\subsection{Ejercicio 12}
\subsubsection{}
$
origen = [x: \varsigma(p)0, y: \varsigma(p)0,mv: \varsigma(p)\lambda(w)\lambda(z) (p.x:=p.x+w).y:=p.y+z]
$
\subsubsection{Una clase es un trait (completo) que además provee un
método new. Clase Punto:}
$
punto =_{def} [new=\varsigma(z)[ l_{i} = \varsigma{s}z.l_{i}(s) i\in(1..n)],$  $x: \varsigma(p)0,$  $y: \varsigma(p)0,$  $mv: \varsigma(p)\lambda(w)\lambda(z) (p.x:=p.x+w).y:=p.y+z]
$
\end{document}
