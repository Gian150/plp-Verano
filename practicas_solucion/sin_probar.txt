-- Gian: Las cosas que hicimos igual, las pasé al pdf

subsection{Ejercicio 15}
    sumaMat :: [[Int]] -> [[Int]] -> [[Int]]
    sumaMat xss yss = map (\(xs,ys) -> mapDoble (+) xs ys) (armarPares xss yss)
    -- Gian: Esto yo lo hice con zipWith (que es lo mismo que mapDoble pero de haskell) y se puede escribir mas conciso:
        sumMat = mapDoble (mapDoble (+))


    trasponer :: [[Int]] -> [[Int]]
    trasponer xss = foldr1 (\xs rec -> mapDoble (:) xs rex) xss
    -- Gian: Acá el caso base no es x, tenes que empezar con una lista de listas vacias, una por cada fila de la nueva matriz.

\subsection{Ejercicio 18}
    type Conj a = (a->Bool)

    vacio :: Conj a
    vacio a = (\x -> True) -- Gian: Aca iba false

    map no se puede definir, porque no podemos hacer referencia a los elementos de la estructura si no los conocemos.

    -- Gian: A mi tambien me parece que no, pero me di cuenta que podemos definir un map que devuelva True cuando un elemento pertenece y que se indefina cuando no XD pero hay que ver si lo toman como valido XD

\subsection{Ejercicio 19}
    trasponer::MatrizInfinita a->MatrizInfinita a
    trasponer m = foldNat (\i rec -> mapDoble (:) (fila i) rec) (length [1..])
    -- No entendí esto y haskell tampoco (?) yo lo hice con un flip

    mapMatriz::(a->b)->MatrizInfinita a->MatrizInfinita b
    mapMatriz f a = map (\i -> (map (\j -> f (a i j) ) [1..])) [1..]
    -- Me parece que acá estas devolviendo listas, no matricesInfinitas

    filterMatriz::(a->Bool)->MatrizInfinita a->[a]
    filterMatriz p a = map (\i -> (filter (\j -> p (a i j) ) [1..])) [1..]
    -- Bien :D, yo lo hice con listas por compresión y usé la tecnica que nos habian dado para imprimir los puntos de un plano en la práctica

    zipWithMatriz::(a->b->c)->MatrizInfinita a->MatrizInfinita b->MatrizInfinita c
    zipWithMatriz f a b = map (\i -> (map (\j -> f (a i j) (b i j) ) [1..])) [1..]
    -- Acá lo mismo que con mapMatriz, map devuelve una lista, no una matrizInfinita


    zipMatriz::MatrizInfinita a->MatrizInfinita b->MatrizInfinita (a,b)
    zipMatriz a b = zipWithMatriz (\x -> \y -> (x,y)) a b
    -- Tambien Bien :D Aca yo puse una función con dos parametros, en vez de funciones parciales