\documentclass[10pt,a4paper, landscape]{article}

\usepackage[pdftex,
pdfauthor={Gianfranco Zamboni},
pdftitle={Resumen: Paradigmas de Lenguajes de Programación},
pdfsubject={},
pdfkeywords={Resumen , Computacion, FCEyN, UBA, Paradigmas de Lenguajes de Programación, Imperativo, Funcional, Cálculo Lambda, Programación Orientada a Objetos, Objetos, Programación Lógica},
pdfproducer={Latex with hyperref},
pdfcreator={pdflatex}]{hyperref}

\usepackage{amsmath}
\usepackage{ amssymb }
\usepackage{bussproofs}
\usepackage{pifont}

\usepackage[spanish]{babel}


\usepackage[utf8]{inputenc} % para poder usar tildes en archivos UTF-8
\usepackage{graphicx}
\usepackage{xcolor}

\usepackage{lscape}
\usepackage{minted}
\usepackage{a4wide} % márgenes un poco más anchos que lo usual
\usepackage[titletoc,toc,page]{appendix}
\usepackage{tikz}
\usepackage{forest}
\usepackage{multicol}

\input{landscape.page.layout}
\input{comandos}

\setlength{\columnsep}{1cm}




\setcounter{section}{2}


\begin{document}
\title{PLP - Práctica 2: Introducción al Cálculo Lambda Tipado}

\date{\today}

\author{Zamboni, Gianfranco}

\maketitle
\setcounter{page}{1}


\section*{\centering Sintaxis}
\subsection{Ejercicio 1}
\begin{multicols}{2}
En este ejercicio, nos piden identificar las expresiones sitacticamente válidas. Tenemos que tener cuidado de no confundir estas expresiones con las expresiones correctamente tipadas. 

Todas las expresiones que nos permite escribir el conjunto de términos son expresiones válidas sintacticamente, aún si estas no pueden ser tipadas.

\end{multicols}

\vspace*{5mm}
\begin{center}
    \begin{tabular}{c|c|c}
        \textbf{Expresiones de términos} & \textbf{Expresiones de tipo} & \textbf{No válidas}\\
        
        $x$ & $\Bool$ & $M$ \\ 
        $x~x$  &  $\Bool\to \Bool$  &  $\sigma$ \\
        $M~M$   & $\Bool\to \Bool\to \Nat$ & $\lambda x.isZero(x)$ \\ 
        $true~false$ &  $(\Bool\to \Bool)\to \Nat$ & $\lambda x:\lambdaIf{true}{\Bool}{\Nat.x}$ \\ 
        $true~succ(true~false)$     &   & $succ~true$ \\ 
        ${\lambdaAbs{x}{\sigma}{succ(x)}}$ &   & \\ 
        $\lambdaAbs{x}{\Bool}{succ(x)}$     &  & \\ 
        $\lambdaAbs{x}{\Bool}{\lambdaIf{0}{true}{\lambdaApp{0}{succ(true)}}}$ &  & \\ 
    \end{tabular}
\end{center}

\vspace*{\fill}
\begin{multicols}{2}
\subsection{Ejercicio 2}

    \begin{forest} tikzQtree,
        [$isZero(pre(succ(\lambdaApp{0}{\lambdaIf{true}{false}{\lambdaAbs{x}{\Nat}{x}}})))$,
        [$pre(succ(\lambdaApp{0}{\lambdaIf{true}{false}{\lambdaAbs{x}{\Nat}{x}}}))$
        [$succ(\lambdaApp{0}{\lambdaIf{true}{false}{\lambdaAbs{x}{\Nat}{x}}})$
        [$\lambdaApp{0}{\lambdaIf{true}{false}{\lambdaAbs{x}{\Nat}{x}}}$
        [$0$]
        [$\lambdaIf{true}{false}{\lambdaAbs{x}{\Nat}{x}}$
        [$true$]
        [$false$]
        [$\lambdaAbs{x}{\Nat}{x}$
        [x]
        ]
        ]                
        ]
        ]
        ]
        ]
    \end{forest}

\subsection{Ejercicio 3}
\paragraph{1.}
$\lambdaAbs{x}{\Nat}{succ((\lambdaApp{\lambdaAbs{x}{\Nat}{\blue{x}})}{\lambdaValue{x}})}$

\paragraph{2. }En el término $\lambdaAbs{x_1}{\Nat}{succ(x_2)}$, $x_1$ no aparece como subtérmino.

\paragraph{3. } La expresión $x~(y~z)$ no sucede en la expresión $u~x~(y~z)$

\begin{center}
    \begin{forest} tikzQtree,
        [$u~x~(y~z)$
        [$u~x$
        [$u$]
        [$x$]
        ]
        [$y~z$
        [$y$]
        [$z$]
        ]
        ]
    \end{forest}
\end{center}

\end{multicols}
\vspace*{\fill}

\newpage
\subsection{Ejercicio 4}
Marcamos con \blue{azul} las variables ligadas y con \red{rojo} las variables libres
\paragraph{a)}

\begin{forest} tikzQtree,
    [$\red{(}\blue{(}\red{u}~\red{x}\blue{)}(\red{y}~\red{z})\red{)}~(\lambdaAbs{v}{\Bool}{\blue{v}})$
    [$\blue{(}\red{u}~\red{x}\blue{)}(\red{y}~\red{z})$
    [$\red{u}~\red{x}$
    [$\red{u}$]
    [$\red{x}$]
    ]
    [$\red{y}~\red{z}$
    [$\red{y}$]
    [$\red{z}$]
    ]
    ]
    [$\lambdaAbs{v}{\Bool}{\blue{v}}$
    [$\red{v}$]
    ]  
    ]
\end{forest}

\paragraph{b)} En esta expresión aparece $(\lambdaAbs{x}{\Bool\to \Nat\to \Bool}{\lambdaAbs{y}{\Bool\to \Nat}{\lambdaAbs{z}{\Bool}{x~z~(y~z)}}})~u$, la marco con una \xmark~ cuando aparece.

\vspace*{5mm}
\begin{forest}tikzQtree,
[$\red{(}\blue{(}(\lambdaAbs{x}{\Bool\to \Nat \to \Bool}{\lambdaAbs{y}{\Bool\to \Nat}{\lambdaAbs{z}{\Bool}{\red{(}\blue{(}\blue{x}~\blue{z}\blue{)}(\blue{y}~\blue{z})\red{)}}}})~\red{u}\blue{)}~\red{v}\red{)}~ \red{w}$
    [$\blue{(}(\lambdaAbs{x}{\Bool\to \Nat\to \Bool}{\lambdaAbs{y}{\Bool\to \Nat}{\lambdaAbs{z}{\Bool}{\red{(}\blue{(}\blue{x}~\blue{z}\blue{)}(\blue{y}~\blue{z})\red{)}}}})~\red{u}\blue{)}~\red{v}$
        [ \xmark $(\lambdaAbs{x}{\Bool\to \Nat\to \Bool}{\lambdaAbs{y}{\Bool\to \Nat}{\lambdaAbs{z}{\Bool}{\red{(}\blue{(}\blue{x}~\blue{z}\blue{)}(\blue{y}~\blue{z})\red{)}}}})~\red{u}$ ,
            [$\lambdaAbs{x}{\Bool\to \Nat\to \Bool}{\lambdaAbs{y}{\Bool\to \Nat}{\lambdaAbs{z}{\Bool}{\red{(}\blue{(}\blue{x}~\blue{z}\blue{)}(\blue{y}~\blue{z})\red{)}}}}$
                [$\lambdaAbs{y}{\Bool\to \Nat}{\lambdaAbs{z}{\Bool}{\red{(}\blue{(}\red{x}~\blue{z}\blue{)}(\blue{y}~\blue{z})\red{)}}}$
                    [$\lambdaAbs{z}{\Bool}{\red{(}\blue{(}\red{x}~\blue{z}\blue{)}(\red{y}~\blue{z})\red{)}}$
                        [$\blue{(}\red{x}~\red{z}\blue{)}(\red{y}~\red{z})$
                            [$\red{x}~\red{z}$
                                [$\red{x}$]
                                [$\red{z}$]
                            ]
                            [$\red{y}~\red{z}$
                                [$\red{y}$]
                                [$\red{z}$]
                            ]
                        ]
                    ]
                ]
            ]
    [$\red{u}$]
    ]
    [$\red{v}$]
    ]
    [$\red{w}$]
]
\end{forest}

\paragraph{c)}
\begin{forest}tikzQtree,
[$\red{(}\blue{(}\red{w}~(\lambdaAbs{x}{\Bool\to \Nat\to \Bool}{\lambdaAbs{y}{\Bool\to \Nat}{\lambdaAbs{z}{\Bool}{\green{(}\red{(}\blue{x}~\blue{z}\red{)}~(\blue{y}~ \blue{z})\green{)}}}})\blue{)}~\red{u}\red{)}~\red{v}$
    [$\blue{(}\red{w}~(\lambdaAbs{x}{\Bool\to \Nat\to \Bool}{\lambdaAbs{y}{\Bool\to \Nat}{\lambdaAbs{z}{\Bool}{\green{(}\red{(}\blue{x}~\blue{z}\red{)}~(\blue{y}~ z)\green{)}}}})\blue{)}~\red{u}$
        [$\red{w}~(\lambdaAbs{x}{\Bool\to \Nat\to \Bool}{\lambdaAbs{y}{\Bool\to \Nat}{\lambdaAbs{z}{\Bool}{\green{(}\red{(}\blue{x}~\blue{z}\red{)}~(\blue{y}~ \blue{z})\green{)}}}})$
            [$\red{w}$]
            [$\lambdaAbs{x}{\Bool\to \Nat\to \Bool}{\lambdaAbs{y}{\Bool\to \Nat}{\lambdaAbs{z}{\Bool}{\green{(}\red{(}\blue{x}~\blue{z}\red{)}~(\blue{y}~ \blue{z})\green{)}}}}$
                [$\lambdaAbs{y}{\Bool\to \Nat}{\lambdaAbs{z}{\Bool}{\green{(}\red{(}\red{x}~\blue{z}\red{)}~(\blue{y}~ \blue{z})\green{)}}}$
                    [$\lambdaAbs{z}{\Bool}{\green{(}\red{(}\red{x}~\blue{z}\red{)}~(\red{y}~ \blue{z})\green{)}}$
                        [$\red{(}\red{x}~\red{z}\red{)}~(\red{y}~ \red{z})$
                            [$\red{x}~\red{z}$
                                [$\red{x}$]
                                [$\red{z}$]
                            ]
                            [$\red{y}~ \red{z}$
                                [$\red{y}$]
                                [$\red{z}$]
                            ]
                        ]
                    ]
                ]
            ]
        ]
        [$\red{u}$]
    ]
    [$\red{v}$]
]
\end{forest}

\newpage
\section*{\centering Tipado}
\subsection{Ejercicio 5}
\paragraph{1)}\begin{scprooftree}
      \def\extraVskip{5pt}
      \AxiomC{}
      \RightLabel{T-True}
      \UnaryInfC{$\judgeType{\phi}{true}{\Bool}$}
      
      \AxiomC{}
      \RightLabel{T-Zero}
      \UnaryInfC{$\judgeType{\phi}{0}{\Nat}$}
      
      \AxiomC{}
      \RightLabel{T-Zero}
      \UnaryInfC{$\judgeType{\phi}{0}{\Nat}$}
      \RightLabel{T-Succ}
      \UnaryInfC{$\judgeType{\phi}{succ(0)}{\Nat}$}
      
      \TrinaryInfC{$\judgeType{\phi}{\lambdaIf{true}{0}{succ(0)}}{\Nat}$}
    \end{scprooftree}

\vspace*{5mm}
\paragraph{2)}
En la siguiente demostración $\Gamma =\{x:\Nat,~y:\Bool\}$
\begin{center}
   \begin{scprooftree}
       \def\extraVskip{5pt}
       
       \AxiomC{}
       \RightLabel{T-True}
       \UnaryInfC{$\judgeType{\Gamma}{true}{\Bool}$}
       
       \AxiomC{}
       \RightLabel{T-False}
       \UnaryInfC{$\judgeType{\Gamma}{false}{\Bool}$}
       
       \AxiomC{$z:\Bool\in \Gamma,z:\Bool$}
       \RightLabel{T-Var}
       \UnaryInfC{$\judgeType{\Gamma,z:\Bool}{z}{\Bool}$}            
       \RightLabel{T-Abs}
       \UnaryInfC{$\judgeType{\Gamma}{\lambdaAbs{z}{\Bool}{z}}{\Bool\to \Bool}$}
       
       \AxiomC{}
       \RightLabel{T-True}
       \UnaryInfC{$\judgeType{\Gamma}{true}{\Bool}$}
       \RightLabel{T-App}
       \BinaryInfC{$\judgeType{\Gamma}{\lambdaApp{(\lambdaAbs{z}{\Bool}{z})}{true}}{\Bool}$}
       
       \RightLabel{T-If}
       \TrinaryInfC{$\judgeType{\Gamma}{\lambdaIf{true}{false}{\lambdaApp{(\lambdaAbs{z}{\Bool}{z})}{true}}}{\Bool}$}
    \end{scprooftree}
\end{center}

\vspace*{5mm}
\paragraph{3)}%
\begin{scprooftree}
    \def\extraVskip{5pt}
    
    \AxiomC{\red{$\judgeType{\phi,x:\Bool}{x}{\Bool}\Rightarrow \judgeType{\phi}{\lambdaAbs{x}{\Bool}{x}}{\Bool\to\tau}$}}
    \RightLabel{T-Abs}
    \UnaryInfC{$\judgeType{\phi}{\lambdaAbs{x}{\Bool}{x}}{\Bool}$}
    
    \AxiomC{$\judgeType{\phi}{0}{\Nat}$}
    
    \AxiomC{$\judgeType{\phi}{succ(0)}{\Nat}$}
    
    \RightLabel{T-If}
    \TrinaryInfC{$\judgeType{\phi}{\lambdaIf{\lambdaAbs{x}{\Bool}{x}}{0}{succ(0)}}{\Nat}$}
\end{scprooftree}

\vspace*{5mm}
\paragraph{4)} En la próxima demostración $\Gamma = \{x : \Bool \to \Nat, y : \Bool\}$ 
\begin{center}
\begin{scprooftree}
    \def\extraVskip{5pt}
    
    \AxiomC{$x:\Bool\to \Nat\in\Gamma$}
    \RightLabel{T-Var}
    \UnaryInfC{$\judgeType{\Gamma}{x}{\Bool \to \Nat}$}
    
    \AxiomC{$y:\Bool\in\Gamma$}
    \RightLabel{T-Var}
    \UnaryInfC{$\judgeType{\Gamma}{y}{\Bool}$}
    \RightLabel{T-App}
    \BinaryInfC{$\judgeType{\Gamma}{\lambdaIf{\lambdaAbs{x}{\Bool}{x}}{0}{succ(0)}}{\Nat}$}
\end{scprooftree}
\end{center}

\newpage
\subsection{Ejercicio 6}

\begin{multicols}{2}
\paragraph{1)}\label{p2:e6:s1}\begin{scprooftree}
    \def\extraVskip{5pt}
    \AxiomC{\red{$\sigma = \Nat$}}
    \RightLabel{T-Zero}
    \UnaryInfC{$\judgeType{\phi}{0}{\sigma}$}
    
    \RightLabel{T-Succ}
    \UnaryInfC{$\judgeType{\phi}{succ(0)}{\sigma}$}
\end{scprooftree}$\Rightarrow \sigma = \Nat$

\paragraph{2)} \begin{scprooftree}
    \def\extraVskip{5pt}
        \AxiomC{}
        \RightLabel{Ejercicio \ref{p2:e6:s1}}
        \UnaryInfC{$\judgeType{\phi}{succ(0)}{\Nat}\Rightarrow \red{\sigma = \Bool}$}
    
    \RightLabel{T-IsZero}
    \UnaryInfC{$\judgeType{\phi}{isZero(succ(0))}{\sigma}$}
\end{scprooftree}$\Rightarrow \sigma = \Bool$

\end{multicols}

\paragraph{3)}
\begin{center}
\begin{scprooftree}
   \def\extraVskip{5pt}
            \AxiomC{}
        \RightLabel{T-True}    
        \UnaryInfC{$\judgeType{\phi}{true}{\Bool}$}

            \AxiomC{}
        \RightLabel{T-True}    
        \UnaryInfC{$\judgeType{\phi}{false}{\Bool}$}

            \AxiomC{}
       \RightLabel{T-True}    
       \UnaryInfC{$\judgeType{\phi}{false}{\Bool}$}

    \RightLabel{T-If}
     \TrinaryInfC{$\judgeType{\Gamma}{\lambdaIf{true}{false}{false}}{\Bool}$}

        \AxiomC{\red{$\sigma = \Nat$}}
    \RightLabel{T-Zero}
    \UnaryInfC{$\judgeType{\phi}{0}{\sigma}$}
    
         \AxiomC{\red{$\sigma = \Nat$}}
    \RightLabel{Ejercicio \ref{p2:e6:s1}}
    \UnaryInfC{$\judgeType{\phi}{succ(0)}{\sigma}$}
            
\RightLabel{T-If}
\TrinaryInfC{$\judgeType{\phi}{\lambdaIf{\lambdaIf{true}{false}{false}}{0}{succ(0)}}{\sigma}$}
    \end{scprooftree}$\Rightarrow \sigma = \Nat$
\end{center}

\subsection{Ejercicio 7}
\begin{multicols}{2}
\paragraph{1)}En la próxima demostración $\Gamma = \{x:\sigma\}$

\vspace*{5mm}
\begin{scprooftree}
       \def\extraVskip{5pt}
\AxiomC{$x:\Nat\in \Gamma$}
\RightLabel{T-Var}
\UnaryInfC{$\judgeType{\Gamma}{x}{\Nat}$}
\RightLabel{T-Succ}
\UnaryInfC{$\judgeType{\Gamma}{succ(x)}{\Nat}$}
\RightLabel{T-Succ}
\UnaryInfC{$\judgeType{\Gamma}{isZero(succ(x))}{\tau}$}
\end{scprooftree}

\vspace*{5mm}
Entonces, $\sigma = \Nat$ y $\tau = \Bool$

\vspace*{5mm}
\paragraph{2)}  \hfil

    \begin{scprooftree}
   \def\extraVskip{5pt}
        
            \AxiomC{$\judgeType{\{x:\sigma\}}{x}{\sigma}$}
       \RightLabel{T-Abs}
        \UnaryInfC{$\judgeType{\phi}{\lambdaAbs{x}{\sigma}{x}}{\sigma\to\sigma}$}
        
            \AxiomC{$\judgeType{\{y:\Bool\}}{0}{\Nat}$}
        \RightLabel{T-Abs}
        \UnaryInfC{$\judgeType{\phi}{\lambdaAbs{y}{\Bool}{0}}{\sigma}$}

\RightLabel{T-App}
\BinaryInfC{$\judgeType{\phi}{\lambdaApp{(\lambdaAbs{x}{\sigma}{x})}{(\lambdaAbs{y}{\Bool}{0})}}{\sigma}$}
    \end{scprooftree}

\vspace*{5mm}
El árbol de la segunda abstracción nos dice que $\sigma = \Bool\to \Nat$. Por lo que la primera abstracción seria la función identidad de funciones del tipo $\Bool\to \Nat$.
\end{multicols}

\paragraph{3)} $\Gamma = \{y:\tau\}$

\vspace*{5mm}
\begin{center}
    \begin{scprooftree}
   \def\extraVskip{5pt}
        
            \AxiomC{\red{$\judgeType{\Gamma,x:\sigma}{x}{\sigma}\Rightarrow \judgeType{\Gamma,x:\sigma}{\lambdaAbs{x}{\sigma}{x}}{\sigma\to \Bool}$}}
       \RightLabel{T-Abs}
        \UnaryInfC{$\judgeType{\Gamma}{\lambdaAbs{x}{\sigma}{x}}{\Bool}$}
        
        \AxiomC{$\judgeType{\Gamma}{y}{\sigma}$}
        
        \AxiomC{$\judgeType{\Gamma}{succ(0)}{\sigma}$}

\RightLabel{T-If}
\TrinaryInfC{$\judgeType{\Gamma}{\lambdaIf{(\lambdaAbs{x}{\sigma}{x})}{y}{succ(0)}}{\sigma}$}
    \end{scprooftree}
\end{center}


\vspace*{5mm}
Entonces, la expresión no es tipable.

\begin{multicols}{2}
\paragraph{4)} $\Gamma = \{x:\sigma\}$

\vspace*{5mm}
    \begin{scprooftree}
   \def\extraVskip{5pt}
        
           \AxiomC{$x: \sigma_1\to\tau\in\Gamma \Rightarrow \sigma = \sigma_1\to\tau$}
       \RightLabel{T-Var}
        \UnaryInfC{$\judgeType{\Gamma}{x}{\sigma_1\to\tau}$}
        
            \AxiomC{\red{$y:\sigma_1\in\Gamma$}}
        \RightLabel{T-Var}
        \UnaryInfC{$\judgeType{\Gamma}{y}{\sigma_1}$}
        

\RightLabel{T-App}
\BinaryInfC{$\judgeType{\Gamma}{x~y}{\tau}$}
    \end{scprooftree}

\vspace*{5mm}
Acá no podemos hacer juicio de tipado porque no podemos asegurar que $y$ sea de tipo $\sigma_1$

\paragraph*{5)}$\Gamma = \{x:\sigma, y:\tau\}$

\vspace*{5mm}
    \begin{scprooftree}
   \def\extraVskip{5pt}
        
           \AxiomC{$x: \sigma_1\to\tau\in\Gamma \Rightarrow \sigma = \sigma_1\to\tau$}
       \RightLabel{T-Var}
        \UnaryInfC{$\judgeType{\Gamma}{x}{\sigma_1\to\tau}$}
        
            \AxiomC{$y:\sigma_1\in\Gamma\Rightarrow \sigma_1 = \tau$}
        \RightLabel{T-Var}
        \UnaryInfC{$\judgeType{\Gamma}{y}{\sigma_1}$}
        

\RightLabel{T-App}
\BinaryInfC{$\judgeType{\Gamma}{x~y}{\tau}$}
    \end{scprooftree}

\vspace*{5mm}
Entonces $\sigma = \tau\to\tau$ para cualquier tipo $\tau$

\paragraph{6)} $\Gamma = \{x:\sigma\}$

\vspace*{5mm}
    \begin{scprooftree}
   \def\extraVskip{5pt}
        
           \AxiomC{$x: \Bool\to\tau\in\Gamma \Rightarrow \sigma = \Bool\to\tau$}
       \RightLabel{T-Var}
        \UnaryInfC{$\judgeType{\Gamma}{x}{\Bool\to\tau}$}
        
        \RightLabel{T-True}
        \AxiomC{$\judgeType{\Gamma}{true}{\Bool}$}
        

\RightLabel{T-App}
\BinaryInfC{$\judgeType{\Gamma}{x~true}{\tau}$}
    \end{scprooftree}
    
\vspace*{5mm}
Entonces $\sigma = \Bool\to\tau$ para cualquier tipo $\tau$

\paragraph{7)} $\Gamma = \{x:\sigma\}$

\vspace*{5mm}
    \begin{scprooftree}
   \def\extraVskip{5pt}
        
           \AxiomC{\red{$x: \Bool\to\sigma\in\Gamma$}}
       \RightLabel{T-Var}
        \UnaryInfC{$\judgeType{\Gamma}{x}{\Bool\to\sigma}$}
        
        \RightLabel{T-True}
        \AxiomC{$\judgeType{\Gamma}{true}{\Bool}$}
        

\RightLabel{T-App}
\BinaryInfC{$\judgeType{\Gamma}{x~true}{\sigma}$}
    \end{scprooftree}
    
\vspace*{5mm}

Tenemos que $x$ debe ser de tipo $\sigma$ y $\Bool\to\sigma$ al mismo tiempo, por lo que no es posible dar un tipo a esta expresión

\paragraph{8)} $\Gamma = \{x:\sigma\}$

\vspace*{5mm}
    \begin{scprooftree}
   \def\extraVskip{5pt}
        
           \AxiomC{\red{$x: \sigma_1\to\tau\in\Gamma$}}
       \RightLabel{T-Var (1)}
        \UnaryInfC{$\judgeType{\Gamma}{x}{\sigma_1\to\tau}$}
        
            \AxiomC{\red{$x: \sigma_1\in\Gamma$}}
        \RightLabel{T-Var (2)}
        \UnaryInfC{$\judgeType{\Gamma}{x}{\sigma_1}$}
        

\RightLabel{T-App}
\BinaryInfC{$\judgeType{\Gamma}{x~x}{\tau}$}
    \end{scprooftree}
    
\vspace*{5mm}

Tenemos que $x$ debe ser de tipo $\sigma$ y $\Bool\to\sigma$ al mismo tiempo, por lo que no es posible dar un tipo a esta expresión

\end{multicols}

\subsection{Ejercicio 8}

La expresión más simple que se me ocurre es $true~false$.

\newpage
\subsection{Ejercicio 9}
El juicio de tipado puede ser $\judgeType{\Gamma}{\lambdaAbs{x}{\sigma}{x}}{\sigma\to\sigma}$

\begin{multicols}{2}
Con T-Abs tenemos:
    \begin{scprooftree}
   \def\extraVskip{5pt}
        
          \AxiomC{$x: \sigma\in\Gamma,x: \sigma$}
        \RightLabel{T-Var}
        \UnaryInfC{$\judgeType{\Gamma,x:\sigma}{x}{\sigma}$}
        

\RightLabel{T-Abs}
\UnaryInfC{$\judgeType{\Gamma}{\lambdaAbs{x}{\sigma}{x}}{\sigma\to\sigma}$}
    \end{scprooftree}

Con T-Abs2:
    \begin{scprooftree}
   \def\extraVskip{5pt}
        
          \AxiomC{\red{$x: \sigma\in\Gamma$}}
        \RightLabel{T-Var}
        \UnaryInfC{$\judgeType{\Gamma}{x}{\sigma}$}
        

\RightLabel{T-Abs2}
\UnaryInfC{$\judgeType{\Gamma}{\lambdaAbs{x}{\sigma}{x}}{\sigma\to\sigma}$}
    \end{scprooftree}

\vspace*{5mm}
No hay nada que nos asegure que $x:\sigma$ pertenece a $\Gamma$
\end{multicols}

\section*{\centering Semántica}
\subsection{Ejercicio 10}
\paragraph{1)} $\replaceBy{(\lambdaAbs{y}{\sigma}{\lambdaApp{x}{(\lambdaAbs{x}{\tau}{x})}})}{x}{(\lambdaAbs{y}{\rho}{\lambdaApp{x}{y}})}\alphaEq{y=w;~x=z}\replaceBy{(\lambdaAbs{w}{\sigma}{\lambdaApp{x}{(\lambdaAbs{z}{\tau}{z})}})}{x}{(\lambdaAbs{y}{\rho}{\lambdaApp{x}{y}})} \equalDef \lambdaAbs{w}{\sigma}{\lambdaApp{(\lambdaAbs{y}{\rho}{\lambdaApp{x}{y}})}{(\lambdaAbs{z}{\tau}{z})}}$

\paragraph{2)}
\begin{equation*}
\begin{split}
\replaceBy{(\lambdaApp{y}{(\lambdaAbs{v}{\sigma}{\lambdaApp{x}{v}})})}{x}{(\lambdaAbs{y}{\tau}{\lambdaApp{v}{y}})} &\equalDef
\lambdaApp{\replaceBy{y}{x}{(\lambdaAbs{y}{\tau}{\lambdaApp{v}{y}})}}{\replaceBy{(\lambdaAbs{v}{\sigma}{\lambdaApp{x}{v}})}{x}{(\lambdaAbs{y}{\tau}{\lambdaApp{v}{y}})}} \equalDef
\lambdaApp{y}{\replaceBy{(\lambdaAbs{v}{\sigma}{\lambdaApp{x}{v}})}{x}{(\lambdaAbs{y}{\tau}{\lambdaApp{v}{y}})}} \\
&\alphaEq{v=z}
\lambdaApp{y}{\replaceBy{(\lambdaAbs{z}{\sigma}{\lambdaApp{x}{z}})}{x}{(\lambdaAbs{y}{\tau}{\lambdaApp{v}{y}})}} \equalDef \lambdaApp{y}{(\lambdaAbs{z}{\sigma}{\lambdaApp{(\lambdaAbs{y}{\tau}{\lambdaApp{v}{y}})}{z}})}
\end{split}
\end{equation*}

\subsection{Ejercicio 11}
\begin{center}
\begin{tabular}{c|c}
\textbf{Es un valor} & \textbf{No es un valor} \\
\hline
$\lambdaAbs{x}{\Bool}{\underline{2}}$ & $\lambdaApp{(\lambdaAbs{x}{\Bool}{x})}{true}$ \\
$\lambdaAbs{x}{\Bool}{pred(\underline{2})}$ &  $x$ \\
$\lambdaAbs{y}{\Nat}{\lambdaApp{(\lambdaAbs{x}{\Bool}{pred(\underline{2})})}{true}}$ &  \\
$succ(succ(0))$ &  \\
\end{tabular}
\end{center}

\newpage
\subsection{Ejercicio 12}
Los programas en \red{rojo} son los que dan error y los programas en \blue{azul} los que son valores, el resto no están en forma normal.
\begin{center}
\begin{tabular}{c|c}
\textbf{Programas} & \textbf{No Programas}\\
\hline
$\lambdaApp{(\lambdaAbs{x}{\Bool}{pred(isZero(x))})}{true}$ & $\lambdaAbs{x}{\Nat}{pred(succ(y))}$\\
\blue{$\lambdaAbs{x}{\Nat}{pred(succ(x))}$} & $\lambdaApp{(\lambdaAbs{f}{\Nat\to \Bool}{x})}{(\lambdaAbs{x}{\Nat}{isZero(x)})}$ \\
\red{$\lambdaApp{(\lambdaAbs{x}{\Bool}{pred(isZero(x))})}{true}$} & \\
$\lambdaApp{(\lambdaAbs{f}{\Nat\to \Bool}{\lambdaApp{f}{0}})}{(\lambdaAbs{x}{\Nat}{isZero(x)})}$ & \\
\red{$\lambdaApp{(\lambdaAbs{f}{\Nat \to \Bool}{\lambdaApp{f}{pred(0)}})}{(\lambdaAbs{x}{\Nat}{isZero(x)})}$} & \\
$\lambdaFix{(\lambdaAbs{y}{\Nat}{succ(y)})}$ & \\
$\lambdaLetrec{f}{\lambdaAbs{x}{\Nat}{succ(\lambdaApp{f}{x})}}{\lambdaApp{f}{0}}$ & \\
\end{tabular}
\end{center}

\vspace*{5mm}
\begin{multicols}{2}
\subsection{Ejercicio 13}
Cuando definimos $\to$, lo hacemos como una función deterministica que dada una expresión, siempre hay una única que regla que aplica para dar un paso en la reducción. Por lo que una expresión siempre reduce a la misma expresión, sin importar cuantos pasos hagamos.

\subsection{Ejercicio 14}
Cuando $M = 0$, tenemos que $succ(pred(0)) = 1$ y que $pred(succ(0)) = 0$, por lo que no siempre es lo mismo evaluar estas dos expresiones. $isZero(succ(M))$ evalúa a $false$ solo cuando $M$ es de tipo Nat y no evalúan a cero. Como dice el enunciado, hay infinitas expresiones que evalúan a cero, recordemos que las (infinitas) expresiones correctamente tipadas evaluán a un valor.3

\subsection{Ejercicio 15}
Con la nueva regla, las abstracciones $\lambdaAbs{x}{\sigma}{M}$ pasan a ser expresiones reducibles mientras $M$ sea una expresión reducible, por lo que debemos considerarla un valor solo cuando su expresión interna es un valor. Además, esta nueva regla nos da un nuevo camino para reducirla cuando ex aplicada a un valor, es decir, en una expresión del tipo $\lambdaApp{\lambdaAbs{x}{\sigma}{M}}{N}$, podemos elegir entre usar esta regla o la regla E-Abs/$\beta$, por lo que hay que modificar esta regla para que solo sea apicable cuando $M$ está en su forma normal $F$, o sea no es posible seguir reduciendola. Entonces:
$$V~::=~ ...~|~\lambdaAbs{x}{\sigma}{V}$$
$$\frac{}{\lambdaApp{\lambdaAbs{x}{\sigma}{F}}{V}\to \replaceBy{F}{x}{V}}(\text{E-Abs/}\beta)$$
Ahora, si tratamos de reducir $\lambdaApp{(\lambdaAbs{x}{\Nat\to\Nat}{\lambdaApp{x}{\underline{23}}})}{(\lambdaAbs{x}{\Nat}{0})}$ nos encontraremos con que la expresión dentro de la primer abstracción es reducible pues $\lambdaApp{x}{\underline{23}}$ no es un valor. Sin embargo,  $x$ puede ser cualquier función de tipo  $\Nat\to\Nat$, o sea que tiene una variable libre, pero no sabemos como ni cuanta veces ocurre dentro de ella. Esto evita que podamos reducirla, trabando la computación.
\end{multicols}


\newpage

\subsection{Ejercicio 16}
\begin{multicols}{2}
Para poder utilizar la reducción \textit{call-by-name} debemos eliminar la regla E-App/$v$ que nos dice que debemos reducir la expresión usada como parámetro hasta obtener un valor y remplazar E-App2/$\beta$ por:
\vfil

$$\frac{}{(\lambdaApp{\lambdaAbs{x}{\sigma}{M})}{N} \to \replaceBy{M}{x}{N}}(\text{E-App/}\beta)$$

Esta nueva regla, nos permite remplazar $x$ por $N$, sin importar si $N$ está en forma normal o no. La próxima reducción se hizo utilizando los cambios mencionados:
\end{multicols}

\begin{equation*}
\begin{split}
&\lambdaApp{(\lambdaApp{\lambdaApp{\lambdaAbs{f}{\Nat\to\Nat}{\lambdaAbs{g}{\Nat\to\Nat}{\lambdaAbs{x}{\Nat}{\lambdaApp{f}{(\lambdaApp{g}{x})}}}})}{(\lambdaAbs{x}{\Nat}{succ(x)})}}{(\lambdaAbs{x}{\Nat}{succ(x)})}}{\underline{5}} \\
&\reduceTo{\text{E-App}/\beta} \lambdaApp{(\lambdaApp{(\lambdaAbs{g}{\Nat\to\Nat}{\lambdaAbs{x}{\Nat}{\lambdaApp{(\lambdaAbs{x}{\Nat}{succ(x)})}{(\lambdaApp{g}{x})}}})}{(\lambdaAbs{x}{\Nat}{succ(x)})}}{\underline{5}}
\reduceTo{\text{E-App}/\beta} \lambdaApp{(\lambdaAbs{x}{\Nat}{\lambdaApp{(\lambdaAbs{x}{\Nat}{succ(x)})}{(\lambdaApp{(\lambdaAbs{x}{\Nat}{succ(x)})}{x})}})}{\underline{5}}\\
&\reduceTo{\text{E-App}/\beta} \lambdaApp{(\lambdaAbs{x}{\Nat}{\lambdaApp{(\lambdaAbs{x}{\Nat}{succ(x)})}{(\lambdaApp{(\lambdaAbs{x}{\Nat}{succ(x)})}{x})}})}{\underline{5}} 
\reduceTo{\text{E-App}/\beta} \lambdaApp{(\lambdaAbs{x}{\Nat}{succ(x)})}{(\lambdaApp{(\lambdaAbs{x}{\Nat}{succ(x)})}{\underline{5}})}
\reduceTo{\text{E-App}/\beta} succ(\lambdaApp{(\lambdaAbs{x}{\Nat}{succ(x)})}{\underline{5}}) \\
&\reduceTo{\text{E-Succ; E-App}/\beta} succ(succ(\underline{5})) 
\end{split}
\end{equation*}

\newpage
\section*{\centering Extensiones}
\subsection{Ejercicio 17}
\paragraph{1)}
\begin{multicols}{2}

 \begin{forest} tikzQtree,
[$\lambdaListCase{0 :: succ(0) :: \List{\Nat}}{false}{isZero(x)}$,
    [$0 :: succ(0) :: \List{\Nat}$,
        [$0$]
        [$succ(0) :: \List{\Nat}$,
            [$succ(0)$]
            [$\List{\Nat}$]
        ]
    ]
    [$false$]
    [$isZero(x)$,
        [$x$]
    ]
]
\end{forest}

 \begin{forest} tikzQtree,
[$\lambdaListFold{1 :: 2 :: 3 ::\lambdaApp{(\lambdaAbs{x}{[\Nat]}{x})}{\List{\Nat}}}{0}{h+r}$,
    [$1 :: 2 :: 3 :: \lambdaApp{(\lambdaAbs{x}{[\Nat]}{x})}{\List{\Nat}}$
        [$1$]
        [$2 :: 3 :: \lambdaApp{(\lambdaAbs{x}{[\Nat]}{x})}{\List{\Nat}}$,
            [$2$]
            [$3 :: \lambdaApp{(\lambdaAbs{x}{[\Nat]}{x})}{\List{\Nat}}$,
                [$3$]
                [$\lambdaApp{(\lambdaAbs{x}{[\Nat]}{x})}{\List{\Nat}}$,
                    [$\lambdaAbs{x}{[\Nat]}{x}$,
                        [$x$]
                    ]
                    [$\List{\Nat}$]
                ]
            ]
        ]
    ]
    [$0$]
    [$h+r$,
        [$h$]
        [$r$]
    ]
]
\end{forest}

\end{multicols}

\paragraph{2)}
\begin{multicols}{2}
$$\frac{}{\judgeType{\Gamma}{\List{\sigma}}{[\sigma]}}(\text{T-Vacio})$$

\vspace*{5mm}
$$\frac{\judgeType{\Gamma}{M}{\sigma}\hspace*{5mm}\judgeType{\Gamma}{N}{[\sigma]}}{\judgeType{\Gamma}{M::N}{[\sigma]}}(\text{T-}::)$$

\vspace*{5mm}
$$\frac{\judgeType{\Gamma}{M}{[\sigma]}\hspace*{5mm}\judgeType{\Gamma}{N}{\tau}~\hspace*{5mm}\judgeType{\Gamma,h:\sigma,xs:[\sigma]}{O}{\tau}}{\judgeType{\Gamma}{\lambdaListCase{M}{N}{O}}{\tau}}(T-Case)$$

\vspace*{5mm}
$$\frac{\judgeType{\Gamma}{M}{[\sigma]}\hspace*{5mm}\judgeType{\Gamma}{N}{\tau}~\hspace*{5mm}\judgeType{\Gamma,h:\sigma,r:\tau}{O}{\tau}}{\judgeType{\Gamma}{\lambdaListFold{M}{N}{O}}{\tau}}(T-Fold)$$

\end{multicols}

\paragraph{3)} $\Gamma = \{x:\Bool,~y:[\Bool]\}$

\vspace*{5mm}
    \begin{scprooftree}
   \def\extraVskip{5pt}

    \AxiomC{Demostración de abajo (1)}
    \UnaryInfC{$\judgeType{\Gamma}{x :: x :: y}{[\Bool]}$}
    
        \AxiomC{$y:[\Bool]\in\Gamma$}
    \RightLabel{T-Var}        
    \UnaryInfC{$\judgeType{\Gamma}{y}{[\Bool]}$}       

        \AxiomC{Demostración abajo (2)}
    \UnaryInfC{$\judgeType{\Gamma,h:\Bool,r:[\Bool]}{\lambdaIf{h}{r}{\List{\Bool}}}{[\Bool]}$}
\RightLabel{T-Fold}
\TrinaryInfC{$\judgeType{\Gamma}{\lambdaListFold{x :: x :: y}{y}{\lambdaIf{h}{r}{\List{\Bool}}}}{[\Bool]}$}
    \end{scprooftree}

\vspace*{2cm}(1)
\begin{scprooftree}
            \AxiomC{$x:\Bool\in\Gamma$}
        \RightLabel{T-Var}
        \UnaryInfC{$\judgeType{\Gamma}{x}{\Bool}$}

                \AxiomC{$x:\Bool\in\Gamma$}
            \RightLabel{T-Var}
            \UnaryInfC{$\judgeType{\Gamma}{x}{\Bool}$}
                
                \AxiomC{$y:[\Bool]\in\Gamma$}
            \RightLabel{T-Var}        
            \UnaryInfC{$\judgeType{\Gamma}{y}{[\Bool]}$}  
                  
        \RightLabel{T-$::$}        
        \BinaryInfC{$\judgeType{\Gamma}{ x :: y}{[\Bool]}$}
        
    \RightLabel{T-$::$}
    \BinaryInfC{$\judgeType{\Gamma}{x :: x :: y}{[\Bool]}$}
\end{scprooftree}

\vspace*{2cm}(2)
\begin{scprooftree}
          \AxiomC{$h:\Bool\in\Gamma,h:\Bool,r:[\Bool]$}
        \RightLabel{T-Var}        
        \UnaryInfC{$\judgeType{\Gamma,h:\Bool,r:[\Bool]}{h}{\Bool}$}       
 
           \AxiomC{$r:[\Bool]\in\Gamma,h:\Bool,r:[\Bool]$}
         \RightLabel{T-Var}        
         \UnaryInfC{$\judgeType{\Gamma,h:\Bool,r:[\Bool]}{r}{[\Bool]}$}       
        
          \AxiomC{}
        \RightLabel{T-Vacio}        
        \UnaryInfC{$\judgeType{\Gamma,h:\Bool,r:[\Bool]}{\List{\Bool}}{[\Bool]}$}       
        
    \TrinaryInfC{$\judgeType{\Gamma,h:\Bool,r:[\Bool]}{\lambdaIf{h}{r}{\List{\Bool}}}{[\Bool]}$}

\end{scprooftree}

\paragraph{4)} Los nuevos valores son $V~::= ...~| \List{\sigma}~|~V::V$

\paragraph{5)}
$$\frac{M_1\to M_1'}{M_1 :: M_2 \to M'_1::M_2}(\text{E-}::\text{1})$$

\vspace*{5mm}
$$\frac{M_2\to M_2'}{V :: M_2 \to V::M'_2}(\text{E-}::\text{2})$$

\end{document}

