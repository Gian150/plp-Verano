\documentclass[10pt,a4paper]{article}
\input{header}

\setcounter{section}{5}

%-----------------------------------------------
%-----------------------------------------------
\usepackage[utf8]{inputenc} % para poder usar tildes en archivos UTF-8
\usepackage[spanish]{babel} % para que comandos como \today den el resultado en castellano
\usepackage{amsmath}
\usepackage{listings}
\usepackage{color}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\newcommand{\quotes}[1]{``#1''}


\usepackage{graphicx}
\usepackage{wrapfig}

\usepackage{tikz}
\usetikzlibrary{graphs}

\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{white}{rgb}{1,1,1}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{white},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}
%-----------------------------------------------
%-----------------------------------------------

\begin{document}
\title{PLP - Práctica 5: Programación Orientada a Objetos}

\date{\today}

\author{Zamboni, Gianfranco}

\maketitle
\setcounter{page}{1}

\section*{\centering Programación en JS}
\subsection{Ejercicio 1}
\subsubsection{Objeto:}
    \begin{lstlisting}
    function c1i(r,i){
    	this.r = r;
    	this.i = i;
    }
    \end{lstlisting}
\subsubsection{Modificando receptor:}
    \begin{lstlisting}
    function c1i(r,i){
    	this.r = r;
    	this.i = i;
    	this.sumar = function (complejo) {
    		this.r += complejo.r;
    		this.i += complejo.i;
    	}
    }
    \end{lstlisting}
\subsubsection{Sin modificar receptor:}
    \begin{lstlisting}
    function c1i(r,i){
    	this.r = r;
    	this.i = i;
    	this.sumar = function (complejo) {
            return (new c1i(this.r + complejo.r, this.i + complejo.i));
    	}
    }
    \end{lstlisting}
\subsubsection{Sumar.Sumar:}
    \begin{lstlisting}
        var c1 = new c1i(1,1);
        var c2 = c1.sumar(c1);
        c2.sumar(c2).mostrar();
    \end{lstlisting}
    Da bien.
\subsubsection{Restar:}
    \begin{lstlisting}
    var c = c1i.sumar(c1i);
    c.protptype.restar = function(complejo){
    	return new c1i(this.r - complejo.r,this.i - complejo.i);	
    }
    \end{lstlisting}
    c1i.restar(c): C1i no tiene definida la operación restar.
\subsubsection{Mostrar:}
    \begin{lstlisting}
    c1i.prototype.mostrar = function () {
    	if(this.i != 1){
    		console.log(this.r+" "+this.i+"i");
    	}else{
    		console.log(this.r+" "+"i");
    	}
    }
    \end{lstlisting}
    c tiene definida la operación mostrar por herencia.
\subsection{Ejercicio 2: a,b y c.}
    \begin{lstlisting}
    function t(a,b) {
    	this.ite = a;
    	this.mostrar = "Verdadero";
    	this.not = "Falso";
    	this.and = function(val){ 
    		if (this.ite == val.ite){
    			return "Verdadero";	
    		}else{
    			return "Falso";
    		}};
    }
    function f(a,b) {
    	this.ite = b;
    	this.mostrar = "Falso";
    	this.not = "Verdadero";
    	this.and = function(val) {
    		return "Falso";
    	}
    }
    \end{lstlisting}
    % console.log((new t(t,f)).mostrar);
    % console.log((new f(t,f)).mostrar);
    % var unTrue = new t(t,f);
    % var unFalse = new f(t,f);
    % console.log(unTrue.and(unTrue));
    % console.log(unTrue.and(unFalse));
    % console.log(unFalse.and(unTrue));
    % console.log(unFalse.and(unFalse));
\subsection{Ejercicio 3: a y b.}
    \begin{lstlisting}
    var cero = {};
    cero.esCero = true;
    cero.succ = function(){ 
    	return new sucesor(this);
    };
    cero.toNumber = 0;
    function sucesor(objeto) {
    	this.esCero = false;
    	this.succ = function(){ 
    		return new sucesor(this);
    	};
    	this.pred = objeto;
    	this.toNumber = objeto.toNumber+1;
    };
    \end{lstlisting}
    % var uno = new sucesor(cero);
    % var dos = new sucesor(uno);
    % console.log(cero);
    % console.log(uno.pred.esCero);
    % console.log(dos.pred.esCero);
    % console.log(dos.toNumber);
\subsubsection{///C}
    \begin{lstlisting}
    \end{lstlisting}
\subsection{Ejercicio 4}
\subsubsection{}
    \begin{lstlisting}
    var Punto = {};
    Punto.neww=function (x,y) {
    	var p = Punto;
    	p.x=x;
    	p.y=y;
    	return p;
    }
    Punto.mostrar=function () {
    	return (this.x+" "+this.y);
    }
    var p = Punto.neww(1 ,2);
    console.log(p.mostrar());
    Punto.mostrar=function (){ return "unPunto"};
    console.log(p.mostrar());
    \end{lstlisting}

\subsubsection{}
    \begin{lstlisting}
    var PuntoColoreado = Punto;
    PuntoColoreado.color = "rojo";
    
    var o = PuntoColoreado.neww(1,2);
    console.log(o.mostrar());
    Punto.mostrar = function (){ return "UnPunto"};
    console.log(o.mostrar());
    PuntoColoreado.mostrar = function (){ return "UnPuntoColoreado"};
    console.log(o.mostrar());
    \end{lstlisting}
\subsubsection{}
    \begin{lstlisting}
    PuntoColoreado.cons = function (x,y,color) {
      var nuevo = this.neww(x,y);
      nuevo.color = color;
      return nuevo;
    }

    var o = PuntoColoreado.cons(2,7,"rojo");
    console.log(o.mostrar());
    Punto.mostrar = function (){ return "UnPunto"};
    console.log(o.mostrar());
    PuntoColoreado.mostrar = function (){ return "UnPuntoColoreado"};
    console.log(o.mostrar());
    \end{lstlisting}
\subsubsection{}
    \begin{lstlisting}
    var p1 = Punto.neww(1 ,2);
    var pc1 = PuntoColoreado.neww(1 ,2);
    Punto.mover = "me muevo";
    var p2 = Punto.neww(1 ,2);
    var pc2 = PuntoColoreado.neww(1 ,2);

    console.log(p1.mover);
    console.log(pc1.mover);
    console.log(p2.mover);
    console.log(pc2.mover);
    \end{lstlisting}
    Se pude observar que todos los objetos se pueden mover, porque los puntos coloreados tienen una referencia a los puntos, por lo tanto si se agrga una funcionalidad al punto, tanbién se agregará al punto coloreado.
    
\subsection{Ejercicio 5}
\subsubsection{}
    \begin{lstlisting}
        function Punto(x,y) {
          this.x=x;
          this.y=y;
        }
        Punto.prototype.mostrar=function () {
          return (this.x+" "+this.y);
        }

        var p = new Punto(1 ,2);
        console.log(p.mostrar());
        Punto.prototype.mostrar=function (){ return "unPunto"};
        console.log(p.mostrar());
    \end{lstlisting}    
\subsubsection{}
    \begin{lstlisting}
    function Punto (x,y) {
    	this.x=x;
    	this.y=y;
    }
    Punto.prototype.mostrar=function () {
    	return (this.x+" "+this.y);
    }
    
    var PuntoColoreado = Punto;
    PuntoColoreado.prototype.color = "rojo";

    var o = new PuntoColoreado(1,2);
    console.log(o.mostrar());
    Punto.prototype.mostrar = function (){ return "UnPunto"};
    console.log(o.mostrar());
    PuntoColoreado.prototype.mostrar = function (){ return "UnPuntoColoreado"};
    console.log(o.mostrar());
    \end{lstlisting}
\subsubsection{}
    \begin{lstlisting}
    function Punto (x,y) {
    	this.x=x;
    	this.y=y;
    }
    Punto.prototype.mostrar=function () {
    	return (this.x+" "+this.y);
    }
    
    var PuntoColoreado = Punto;
    PuntoColoreado.prototype.color = "rojo";
    PuntoColoreado.cons = function (x,y,color) {
      var nuevo = new Punto(x,y);
      nuevo.color = color;
      return nuevo;
    }

    var o = new PuntoColoreado(1,2);
    console.log(o.mostrar());
    Punto.prototype.mostrar = function (){ return "UnPunto"};
    console.log(o.mostrar());
    PuntoColoreado.prototype.mostrar = function (){ return "UnPuntoColoreado"};
    console.log(o.mostrar());
    \end{lstlisting}
\subsubsection{}
    \begin{lstlisting}
    \end{lstlisting}
\subsection{Ejercicio 6}
\subsubsection{}
    \begin{lstlisting}
    function C1(){};
C1.prototype.g = " Hola ";

function C2 () {};
C2.prototype.g = " Mundo ";

let a = new C1();
C1.prototype = C2.prototype;
let b = new C1();

console.log(a.g);
console.log(b.g);
    \end{lstlisting}

Hola Mundo
Esto es porque a partir de la asignacion de prototipos, lo que cambia es la forma de generar nuevas instancias de C1, pero no las anteriores.

    \begin{lstlisting}
let c = new C1();
C1.prototype.g = C2.prototype.g;
let d = new C1();

console.log(c.g);
console.log(d.g);
    \end{lstlisting}
Mundo Mundo
En cambio, aqui se modifica un método del prototipo de C1, por lo tanto, aun las instancias ya creadas verán la modificacion.
\subsection{Ejercicio 7}
\subsubsection{}
    \begin{lstlisting}
    var o = {a:1, b: function (x){ return x+a }};
    var o1 = Object.create(o);
    o1.c = true ;
    var a = new Array ;
    var b = new Array ;
    for (k in o1) {
    	a.push(k); 
    	b.push(o1[k]);
    }
    
    console.log(a);
    console.log(b);
\end{lstlisting}
Resultado:
$a:["c", "a", "b"]$
$b:[true, 1, ƒ]$
Que proviene de la iteracion de todos los métodos de o1;
\subsubsection{}
    \begin{lstlisting}
    function extender (ob, ob2) {
    	var encontrado = false;
    	for (k in ob){
    		encontrado=false;
    		for (j in ob2){
    			if(j==k){
    				encontrado=true;
    			}
    		}
    		if (!encontrado) {
    			ob2[k]=ob[k];
    		};
    	} 
    }
    var ob = {a:10,b:20};
    var ob2 = {c:30,d:10,a:2};
    extender(ob,ob2)
    console.log(ob);
    console.log(ob2);
    \end{lstlisting}
\subsubsection{}
    \begin{lstlisting}
    delete A.presentar;
    \end{lstlisting}
\subsubsection{}
    \begin{lstlisting}
    \end{lstlisting}

\section*{\centering Cálculo de Objetos}

\subsection{Ejercicio 8}
\subsubsection{}
Representan al mismo objeto porque responden a los mismos mensajes. la unica variacion que se observa es el renombre del parametro this entre x,z,v.
\subsubsection{}
Representan a distintos objetos porque responden a los distintos mensajes.
\subsection{Ejercicio 9}
$o =_{def} [arg = \varsigma(x)x; val = \varsigma(x)x.arg].$
\subsubsection{o.val}
\vspace*{5mm}
	\begin{center}
		\begin{scprooftree}
		    
		    \AxiomC{}
		    \RightLabel{[Obj]}
		    \UnaryInfC{$o \rightarrow o$}
		    
		    \AxiomC{}
		    \RightLabel{[Obj]}
		    \UnaryInfC{$o \rightarrow o$}

		    \AxiomC{}
		    \RightLabel{[Obj]}
		    \UnaryInfC{$(x)\{x \leftarrow o\} \rightarrow o$}
		    
		    \RightLabel{[Sel]}
		    \BinaryInfC{$(x.arg)\{x \leftarrow o\} \rightarrow o$}
		    
		    \RightLabel{[Sel]}
            \BinaryInfC{$o.val \rightarrow o$}
		\end{scprooftree}    
	\end{center}
\subsubsection{\blue{o.val.arg}}
\vspace*{5mm}
	\begin{center}
		\begin{scprooftree}
		
		    \AxiomC{}
		    \RightLabel{[Obj]}
		    \UnaryInfC{$o \rightarrow o$}
		    \RightLabel{[Obj]}
		    \UnaryInfC{$o.val \rightarrow o$}
    		    \AxiomC{}
    		    \RightLabel{[Obj]}
    		    \UnaryInfC{$o \rightarrow o$}
    		    \RightLabel{[Obj]}
    		    \UnaryInfC{$o.val \rightarrow o$}
            		\AxiomC{}
        		    \RightLabel{[Obj]}
        		    \UnaryInfC{$o \rightarrow o$}
        
        		    \AxiomC{}
        		    \RightLabel{[Obj]}
        		    \UnaryInfC{$(x)\{x \leftarrow o\} \rightarrow o$}
        	    \RightLabel{[Sel]}
    		    \BinaryInfC{$(x.arg)\{x \leftarrow o\} \rightarrow o$}
		    \RightLabel{[Sel]}
		    \BinaryInfC{$(x)\{x \leftarrow o.val\} \rightarrow o$}
		    \RightLabel{[Sel]}
        \BinaryInfC{$o.val.arg \rightarrow o$}
		\end{scprooftree}    
	\end{center}

\subsubsection{$(o.arg \Leftarrow \Sigma(z)0).val$}
\subsection{Ejercicio 10}
\subsection{Ejercicio 11}
\subsubsection{Objetos true y false:}
$
true = [not: \varsigma(x)false,if: \varsigma(x)\lambda(y)\lambda(z)y,ifnot: \varsigma(x)\lambda(y)\lambda(z)z]
$ \\
$
false = [not: \varsigma(x)true,if: \varsigma(x)\lambda(y)\lambda(z)z,ifnot: \varsigma(x)\lambda(y)\lambda(z)y]
$
\subsubsection{}
$
true = [not: \varsigma(x)false,if: \varsigma(x)\lambda(y)\lambda(z)y]
$ \\
$
false = [not: \varsigma(x)true,if: \varsigma(x)\lambda(y)\lambda(z)z]
$
\subsection{Ejercicio 12}
\subsubsection{}
$
origen = [x: \varsigma(p)0, y: \varsigma(p)0,mv: \varsigma(p)\lambda(w)\lambda(z) (p.x:=p.x+w).y:=p.y+z]
$
\subsubsection{Una clase es un trait (completo) que además provee un
método new. Clase Punto:}
$
punto =_{def} [new=\varsigma(z)[ l_{i} = \varsigma{s}z.l_{i}(s) i\in(1..n)],$  $x: \varsigma(p)0,$  $y: \varsigma(p)0,$  $mv: \varsigma(p)\lambda(w)\lambda(z) (p.x:=p.x+w).y:=p.y+z]
$
\subsubsection{}
    \begin{lstlisting}
    \end{lstlisting}
\subsubsection{}
    \begin{lstlisting}
    \end{lstlisting}
\subsection{Ejercicio 13}
\subsubsection{}
    \begin{lstlisting}
    \end{lstlisting}
\subsubsection{}
    \begin{lstlisting}
    \end{lstlisting}
\subsubsection{}
    \begin{lstlisting}
    \end{lstlisting}
\subsubsection{}
    \begin{lstlisting}
    \end{lstlisting}
\subsubsection{}
    \begin{lstlisting}
    \end{lstlisting}
\subsubsection{}
    \begin{lstlisting}
    \end{lstlisting}

\end{document}
