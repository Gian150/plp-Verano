\section{Objetos y el modelo de cómputo}

En el parádigma orientado a objetos, todo programa es una simulación representada por una entidad u \textbf{objeto} que asocia los objetos físicos o conceptuales de un dominio del mundo real en objetos del dominio del programa. Estos objetos tienen las características y capacidades del mundo real que nos interesa modelar y se comunican entre si a través de intercambios de mensajes.

Los mensajes intercambiados son solicitudes para que el objeto \textbf{receptor} del mismo lleve a cabo una de sus operaciones. El \textbf{receptor} determinara si puede llevar a cabo dicha operación y, si puede hacerlo la ejecutará.

\subsection{Objetos}
Entonces un objeto es una entidad del programa que puede recibir un conjunto de mensajes (al que llamaremos \textbf{interfaz} o \textbf{protocolo}) que le permite determinar como llevar a cabo ciertas operaciones. Internamente, estará compuesto por un conjunto de \textbf{colaboradores internos} (tambien llamados \textbf{atributos} o \textbf{variables internas}) que determinan su \textbf{estado interno} y por un conjunto de \textbf{métodos} que describen (implementan) las operaciones que puede realizar y, si estas afectan a su estado interno, como lo hacen.

\paragraph{Principio de ocultamiento de la información}
El estado de un objeto es \textbf{privado} y solamente puede ser consultado o modificado por sus propios métodos, por lo que su implementación no depende de los detalles de implementación de otros objetos. Y la única forma que tenemos de interactuar con el mismo es enviándole los mensajes definidos en su interfaz.

\paragraph{Method dispatch} Es el método mediante el cuál, un proceso, estable la asociación entre el mensaje y el método a ejecutar. Es decir, cuando un objeto recibe un mensaje, el \textbf{method dispatch} se encarga de hallar la \textbf{declaración del método} que se pretende ejecutar. Este método puede ser \textbf{estático} (realizado en tiempo de compilación) o \textbf{dinámico} (realizado en tiempo de ejecución).

\paragraph{Corrientes de organización}
Por lo general,tratamos de agrupar los objetos en conjuntos compuestos por objetos que se comportan de manera similar para conseguir programas más concisos. Esto se puede hacer de dos formas: Mediante clasifiación o mediante prototipado.

\section{Clasificación}
Se usan \textbf{clases} que modelan \textbf{conceptos abstractos} del dominio del problema a resolver y definen el comportamiento y la forma de un conjunto de objetos (sus \textbf{instancias}). Todo \textbf{objeto} es una instancia de una clase.

\paragraph{Componentes de una clase}
Todas las clases tienen un \textbf{nombre} que usado para referenciarse a la misma. Dentro de ellas se definen las variables de instancias (colaboradores internos) de los objetos) y los métodos que saben responder esas instancias (sus nombres, sus parámetros y su cuerpo).

\subsection{Self/This}
Todas las clases tienen definida una pseudovariable que, durante la evaluación de un método, referencia al receptor del mensaje que activó dicha evaluación. No puede ser modificada por medio de una asignación y se liga automáticamente al receptor cuando comienza la evaluación del método.

\begin{minted}{smalltalk}
!classDefinition: #Node 
	instanceVariableNames: 'leftchild, rightchild'
	...
sum: 
	^ (self leftchild) sum + (self rightchild) ! !
	
!classDefinition: #Leaf 
	instanceVariableNames: 'value'
	...
sum: 
	^self value ! !

\end{minted}

Vemos que los métodos acceden a sus variables de instancia, enviándose a si mismos el mensaje asociado a cada una de ellas. En muchos lenguajes, para facilitar la escritura de un programa, la mención de \texttt{self} se hace implícitamente.

\subsection{Jerarquía de clases}
Cuando escribimos un programa en este paradigma, es común que creemos nuevas clases que extiendan a las ya existentes con nuevas variables de instancia o clase o que modifiquen el comportameiento de unos o varios métodos.

Para evitar tener que escribir toda una clase de cero, hacemos que la clase que estamos creando \textbf{herede} los atributos y los métodos de la clase pre-existente (la \textbf{super-clase}) que queremos extender. De esta forma, la nueva clase tendrá todo lo que tenía la super-clase y, además, las modificaciones que nosotros querramos agregarle.

La herencia define una relación transitiva por lo que si una clase $A$ tiene como super-tipo a otra clase $B$, entonces el super-tipo $C$ de $B$, entonces $C$ tambien es supertipo de $A$. Llamaremos \textbf{ancestros} a todos los supertipos de $A$ y \textbf{descendientes} a todos los tipos que tienen a $A$ como ancestro.

\subsection{Tipos de herencia}
Hay dos tipos de herencia: \textbf{simple} y \textbf{múltiple}. La herencia simple permite que una clase tenga una única clase padre y la única clase que no tiene padre es la clase \texttt{Object} que es la clase de la que heredan todas las demás. Mientras que la herencia múltiple deja que una clase tenga varios padres.

La mayoría de los lenguajes orientados a objetos utilizan la primera ya que la herencia múltiple complica el proceso de method dispath (que asocia los mensajes de un objeto con sus respectivos métodos). Para ver por qué pasa esto, supongamos que tenemos dos clases $A$ y $B$ incomparables y una clase $C$ que es subclase de $A$ y $B$. Si $A$ y $B$ definen (o heredan) dos métodos diferentes para un mismo mensaje $m$, entonces cuando enviemos dicho mensaje a $C$ deberíamos saber cual de los dos elegir.

Hay dos soluciones posibles a este problema:
\begin{itemize}
\item Podemos establecer un \textbf{orden de búsqueda} sobre las superclases de un clase estableciendo, de esta forma, un nivel de prioridad sobre algunas de ellas.
\item O obligar al programado a \textbf{redefinir} el método en $C$ si $C$ hereda dos métodos distintos para el mismo mensaje.
\end{itemize}

\subsubsection{Method Dispatch}

Como dijimos, el \textbf{method Dispatch} es el método mediante el cual asociamos un mensaje a su método correspondiente en el objeto. Por lo general, este método se realiza de manera dinámica, es decir se realizan durante tiempo de ejecución dependiendo del contexto sin embargo, hay situaciones en las que realizar este proceso de manera estática es necesario. 

Un ejemplo de esto, es cuando el lenguaje nos permite hacer uso de \texttt{super}, una pseudovariable que \textbf{referencia al objeto que recibe el mensaje} y \textbf{cambia} su proceso de activación al momento de recibir un mensaje.
Cuando usamos una expresión de la forma \texttt{super msg} en el cuerpo de un método $m$, el \textbf{method lookup} (la búsqueda del método realizada por el method dispath), comienze a realizarse desde el padre de la \textbf{clase anfitriona} de m.

Algunos lenguajes, además, nos permiten pasarle como parámetro una clase a partir de la que empezar de la siguiente forma: \texttt{super[A] msg}, siempre y cuando $A$ sea un ancestro de la clase anfitriona del método.

\section{Prototipado}
Lo lenguajes basados en prototipado de objetos se caracterizan por la ausencia de clases. Proveen constructores para la creación de objetos particulares y la herramientas necesarias para crear procedimientos que generen objetos.

En este tipo de paradigma, creamos instancias concretas que se interpretan como representantes canónicos de instancias (llamados \textbf{prototipos}) y, a partir de ellos, generamos otras intancias (\textbf{clones}) que pueden ser modificados sin afectar al prototipo.

Cuando hacemos esto hacemos lo que se llama una \textbf{shallow copy}, es decir copiamos cada atributo de un objeto $A$ en otro $B$. Es decir, si en $A$ tenemos una referencia a $C$, entonces en $B$ tendremos una referencia a $C$, no copiaremos $C$ a ningún otro objeto.

\subsection{Cálculo de objetos no tipado \texorpdfstring{($\varsigma$ cálculo)}{}}
Usaremos un lenguaje cuya única estructura computacional son los \textbf{Objetos}. Estos objetos son una colección de atributos nombrados (\textbf{registros}) que están asociados a métodos con una única variable ligada (que representa a \texttt{self}/\texttt{this}) y un cuerpo que produce un resultado.

Todos los objetos proveen dos operaciones:

\paragraph{Envío de mensajes:} Que nos permite invocar un método para que el objeto ejecute.

\paragraph{Redefinición de un método:} Que nos permite reemplazar el cuerpo de un atributo por otro.

\subsubsection{Sintaxis}
\begin{tabular}{lllll}
	$a,b$ &$::=$& &$x$ & Variables \\
 	      &     & $|$ &$[\OOAtributo{l_i}{x_i}{b_i}^{i\in1..n}]$ &  Objetos\\
 	      &     & $|$ &$a.l$ &  Selección/ Envío de mensajes \\
 	      &     & $|$ &$\OORedefinicion{a.l}{x}{b}$ &  Redefinición de un método.	       	       	      
\end{tabular}

\vspace*{5mm}
El objeto $[~]$ es el objeto vacío y no proporciona ningún método.

En este lenguajes, como todos los átributos son métodos, simulamos los colaboradores internos de un objeto con métodos que no utilizan el parámetro \texttt{self}. Por ejemplo:

$$o \equalDef [\OOAtributo{l_1}{x_1}{[~]},~
				\OOAtributo{l_2}{x_2}{x_2.l_1}]$$

$o.l_1$ retorna un objeto vacío. Y $o.l_2$ envia el mensaje $l_1$ a \texttt{self} (representado por el parámetro $x_2$). 

\paragraph{Notación} Cuando un objeto tenga un atributo de la forma $\OOAtributo{l}{x}{b}$ y $x$ no se usa en $b$ podemos escribir $l = b$ y a la reasignación $\OORedefinicion{o.l}{x}{b}$ como $o.l := b$.

\paragraph{Variables libres}
$\varsigma$ es un ligador de variables, cuando lo usamos en una expresión de la forma $\varsigma(x)b$ siempre liga la variable $x$ que se le pasa como párametro a \texttt{self}. Osea que cuando $x$ aparece en $b$ será remplazada por \texttt{self}.

De manera análoga a $FV$ del cálculo $\lambda$ definimos fv para objetos y diremos que un término $a$ es \textbf{cerrado} si fv($a$) = $\emptyset$:

\begin{center}
\begin{tabular}{ll}
	$\text{fv}(\varsigma(x)b)$ &$= \text{fv}(b)\backslash \{x\} $\\
	$\text{fv}(x)$ &$= \{x\} $\\
	$\text{fv}([\OOAtributo{l_i}{x_i}{b_i}^{i\in 1..n}])$ &$=  \bigcup^{1\in 1..n} \text{fv}(\varsigma(x)b)$\\
	$\text{fv}(a.l)$ &$= \text{fv}(a) $\\
	$\text{fv}(\OORedefinicion{a.l}{x}{b})$ &$= \text{fv}(a.l)\cup \text{fv}(\varsigma(x)b) $\\
\end{tabular}
\end{center}
\paragraph{Sustitución} La función de sustitución de variables libres para objetos está definida de la siguiente forma:

\begin{center}
\begin{tabular}{lll}
	$x\{x \leftarrow c\}$ &$= c$ & \\
	$y\{x \leftarrow c\}$ &$= y$ & si $x\neq y$\\
	$([\OOAtributo{l_i}{x_i}{b_i}^{i\in 1..n}])\{x \leftarrow c\}$ &$=  [l_i = (\varsigma(x_i)b_i)\{x \leftarrow c\}^{i\in 1..n}]$ & \\
	$(a.l)\{x \leftarrow c\}$ &$= (a\{x \leftarrow c\}).l $ & \\
	$(\OORedefinicion{a.l}{x}{b})\{x \leftarrow c\}$ &$= (a\{x \leftarrow c\}).l \leftleftharpoons (\varsigma(x)b)\{x \leftarrow c\} $ & \\
	$(\varsigma(y)b)\{x \leftarrow c\}$ &$= (\varsigma(y')(b\{y \leftarrow y'\}\{x \leftarrow c\})) $ & si $y'\notin$fv$(\varsigma(y)b)\cup$fv$(c)\cup\{x\}$ \\
\end{tabular}
\end{center}

Notemos que en el último caso, remplazamos $y$ por $y'$ por si $y = x$ asegurandonos, de esta manera, que no cambiamos el significado de la expresión.

\paragraph{$\alpha$-converión} En objetos decimos que dos métodos son equivalentes, si tienen el mismo cuerpo salvo renombre de variables, es decir: $\varsigma(x)b$ y $\varsigma(y)(b\{x\leftarrow y\})$ con $y\notin~\text{fv}(b)$ son equivalentes.

Además, dos objetos $o_1$ y $o_2$ son considerados equivalentes ($o_1 \equiv o_2$) si solo difieren en el orden se sus componentes. Si 

\begin{align*}
	o_1 \equalDef [l_1 = [~],~\OOAtributo{l_2}{x_2}{x_2.l_1}] \\
	o_2 \equalDef [\OOAtributo{l_2}{x_3}{x_3.l_1}, l_1 = [~]]
\end{align*}

son equivalentes porque ambos objetos tiene los atributos $l_1$ y $l_2$ y $\varsigma(x_2) x_2.l_1 =_\alpha \varsigma(x_3) x_3.l_1$.


\subsubsection{Semántica operacional}
Todos los objetos son considerados valores.
$$V~::=~[\OOAtributo{l_i}{x_i}{b_i}^{1\in 1..n}]$$

A diferencía del cálculo $\lambda$, usaremos el método de reducción \textbf{big-step} para evaluar expresiones, que en un solo paso nos permite saber el valor que representa.