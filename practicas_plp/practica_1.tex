\section{Práctica 1}
\subsection{Ejercicio 1}
\begin{centrado}
\begin{minted}[breaklines]{haskell}
-- La función max de Prelude ya hace esto
max2 ::(Float, Float) -> Float
max2 (x, y) | x >= y = x        
            | otherwise = y

max2Currificada :: Float -> Float -> Float
max2Currificada x y | x >= y = x
         | otherwise = y

normaVectorial :: (Float, Float) -> Float
normaVectorial (x, y) = sqrt (x^2 + y^2)

normaVectorial :: Float -> Float -> Float
normaVectorial x y = sqrt (x^2 + y^2)

-- subtract ys esta definida en Prelude
subtract1 :: Float -> Float -> Float  
subtract1 = flip (-)

-- La función pred definida en Prelude ya hace esto
predecesor :: Float -> Float  
predecesor = subtract 1

evaluarEnCero :: (Float -> b) -> b
evaluarEnCero = \f -> f 0

dosVeces :: (a -> a) -> (a -> a)
dosVeces = \f -> f.f

flipAll :: [a -> b -> c] -> [ b -> a -> c]
flipAll = map flip

flipRaro :: b -> ( a -> b -> c ) -> a -> c
flipRaro = flip flip
\end{minted}
\end{centrado}

\subsection{Ejercicio 2}
\begin{centrado}
\begin{minted}[breaklines]{haskell}
[ x | x <- [1..3], y <- [x..3], ( x + y ) `mod` 3 == 0 ] 
  = [ 1, 3 ]
\end{minted}
\end{centrado}

\newpage
\subsection{Ejercicio 3}
\begin{centrado}
\begin{minted}[breaklines]{haskell}
pitagoricas :: [(Integer, Integer, Integer)]
pitagoricas =[(a, b, c) | a <- [1..], b <-[1..], c <- [1..], 
               a^2 + b^2 == c^2]
\end{minted}
\end{centrado}

Esta definición agrega la tupla \mintinline{haskell}{(1,1,1)} a la lista y luego aumenta \mintinline{haskell}{c} infinitamente, sin encontrar ningun nueva coincidencia. Si cambiamos el orden en el que se recorren las listas y agregando algunas cotas de la siguiente forma:
\begin{centrado}
\begin{minted}[breaklines]{haskell}
pitagoricas :: [(Integer, Integer, Integer)]
pitagoricas = [ (a, b, c) | c <- [1..], b <-[1..c], a <- [1..c],
                 a^2 + b^2 == c^2]
\end{minted}
\end{centrado}
En este caso, para cada número probamos todas las combinaciones de pares \mintinline{haskell}{(a,b)} tales que la suma de sus cuadrados podría llegar a dar \texttt{c}. Como \texttt{a} y \texttt{b} están acotados por \texttt{c}, ya que claramante \mintinline{haskell}{c^2 + c^2 > c^2}, la cantidad de pruebas de pares para cada número es finita ($2^c$ pares) y es posible pasar al siguiente número una vez realizados estos chequeos.


\subsection{Ejercicio 4}
\begin{centrado}
\begin{minted}[breaklines]{haskell}
primerosPrimos :: Int -> [Int]
primerosPrimos n = take n [ x | x <- [2..], esPrimo x ]
\end{minted}
\end{centrado}

Gracias a la evaluación \textit{lazy}, cuando se encuentran los primeros \texttt{n} primos la función deja de computar la lista de primos.

\subsection{Ejercicio 5}
\begin{centrado}
	\begin{minted}[breaklines]{haskell}
partir :: [a] -> [ ([a], [a]) ]
partir xs = [ (take i xs, drop i xs) | i <- [0..(length xs)] ]
	\end{minted}
\end{centrado}

\subsection{Ejercicio 6}
\begin{centrado}
\begin{minted}[breaklines,tabsize=2]{haskell}
listasQueSuman :: Int -> [[Int]]
listasQueSuman 1 = [[1]]
listasQueSuman n = [n]:( concat 
	[ map ( (n-i): ) ( listasQueSuman i ) | i <- [ 1..n-1 ] ] ) 
\end{minted}
\end{centrado}


\textbf{A preguntar:}
%La función definiida usa recursión explicita. Podemos definir el esquema recursivo \texttt{indcucciónGlobal} y volver a definir listasQueSuman usando este esquema:
%
%\begin{centrado}
%\begin{minted}[breaklines,tabsize=2]{haskell}
%induccionGlobal:: (Int -> Int -> b -> b) -> 
%	(Int -> [b] -> b) -> b -> Int -> b
%induccionGlobal _ _ z 1 = z
%induccionGlobal g f z n = 
%	f n [ g n i ( induccionGlobal g f z i ) | i <- [ 1..(n-1) ] ]
%
%listasQueSumanIG :: Int -> [[Int]]
%listasQueSumanIG n = induccionGlobal
%(\i j -> map ((i-j):) )
%(\x xs -> [x]:(concat xs)) 
%[[1]] n
%\end{minted}	
%\end{centrado}
%
%El esquema \texttt{induccionGlobal} nos permite definir funciones recursivas en las que el resultado de la función depende de todos los casos anteriores, no solo del caso anterios.
%
\subsection{Ejercicio 7}

\begin{centrado}
	\begin{minted}[breaklines, tabsize=2]{haskell}
listasFinitas :: [[Int]]
listasFinitas = concat [ listasQueSuman i | i <- [1..]]
\end{minted}
\end{centrado}	

\subsection{Ejercicio 8}
\begin{centrado}
	\begin{minted}[breaklines, tabsize=2]{haskell}
-- curry y uncurry ya están definidas en Prelude
curry1 :: ((a,b) -> c) -> a -> b -> c
curry1 f a b = f (a,b)
	\end{minted}
\end{centrado}

\begin{centrado}
\begin{minted}[breaklines, tabsize=2]{haskell}
uncurry1 :: (a -> b -> c) -> (a, b) -> c
uncurry1 f (a, b) = f a b
	\end{minted}
\end{centrado}

\textbf{A preguntar:} %No podemos definir una función \texttt{curryN} que tome una función con un número arbitrario de parametros, ya que la cantidad de parámetros de la función currificada depende de la cantidad de parámetros de la función original. Esto significa que \texttt{curryN} debería poder modificar la cantidad de parámetros que toma dependiendo de la función que se le pasa, lo que es imposible.
%Otra idea sería tratar de definirla de manera que dada una función vaya remplazando los parámetros de a poco generando, de esta forma, n funciones parciales. Pero esto es imposible ya que la función debe tener la tupla de parámetros completa para poder ser evaluada de cualquier manera.

\subsection{Ejercicio 9}
\begin{centrado}
	\begin{minted}[breaklines,tabsize=2]{haskell}
dc :: DivideConquer a b
dc esTrivial resolver repartir combinar x = 
	if esTrivial x then 
		resolver x 
	else combinar (map  dc1 (repartir x))
	where dc1 = dc esTrivial resolver repartir combinar

\end{minted}
\end{centrado}

\begin{centrado}
	\begin{minted}[breaklines,tabsize=2]{haskell}
mergesort :: Ord a => [a] -> [a]
mergesort = dc ((<=1).length)
	id
	partirALaMitad
	(\[xs,ys] -> merge xs ys)	
	\end{minted}
\end{centrado}

\begin{centrado}
	\begin{minted}[breaklines,tabsize=2]{haskell}
mapD :: (a -> b) -> [a] -> [b]
mapDC f = dc ((<=1).length)
	( \xs -> if (length xs) == 0 then [] else [ f (head xs) ] )
	partirALaMitad
	concat

filterDC :: (a -> Bool) -> [a] -> [a]
filterDC p = dc ((<=1).length)
	(\xs -> if (length xs == 0) || (p (head xs)) then [] else xs )
	partirALaMitad
	concat
	\end{minted}
\end{centrado}

\begin{centrado}
	\begin{minted}[breaklines,tabsize=2]{haskell}
-- Auxiliares

partirALaMitad :: [a] -> [[a]]
partirALaMitad xs = [ take i xs, drop i xs ] 
	where i = (div (length xs) 2)

merge :: Ord a => [a] -> [a] -> [a]
merge = foldr 
	(\y rec -> (filter (<= y) rec) ++ [y] ++ (filter (>y) rec))	 
	\end{minted}
\end{centrado}

\subsection{Ejercicio 10}
\begin{centrado}
	\begin{minted}[breaklines,tabsize=2]{haskell}
sumFold :: Num a => [a] -> a
sumFold = foldr (+) 0

elemFold :: Eq a => a -> [a] -> Bool
elemFold x = foldr (\y rec -> (y==x) || rec) False

masMasFold :: [a] -> [a] -> [a]
masMasFold = flip (foldr (\x rec-> x:rec) )

mapFold :: (a->b) -> [a] -> [b]
mapFold f = foldr (\x rec-> (f x):rec) []

filterFold :: (a->Bool) -> [a] -> [a]
filterFold p = foldr (\x rec -> if (p x) then x:rec else rec) []
	\end{minted}
\end{centrado}

La función \mintinline{haskell}{foldr1 :: Foldable t => (a -> a -> a) -> t a -> a} está definida en Prelude. Esta función es una variante de \mintinline{haskell}{foldr} en la que el caso base se da cuando la estructura contiene un único elemento y ese elemento es el resultado del caso base.

\begin{centrado}
	\begin{minted}[breaklines, tabsize=2]{haskell}
mejorSegun :: (a -> a -> Bool) -> [a] -> a
mejorSegun f xs = 
	foldr1 (\x rec -> if f x rec then x else rec) xs
	\end{minted}
\end{centrado}

\begin{centrado}
	\begin{minted}[tabsize=2,breaklines]{haskell}
sumaAlt :: Num a => [a] -> a   -- Preguntar
	\end{minted}
\end{centrado}

\begin{centrado}
	\begin{minted}[tabsize=2,breaklines]{haskell}
sumaAlt2 :: Num a => [a] -> a   -- Preguntar
	\end{minted}
\end{centrado}

\begin{centrado}
	\begin{minted}[tabsize=2,breaklines]{haskell}
permutaciones :: [a] -> [[a]]
permutaciones = foldr 
	(\x rec-> concatMap (agregarEnTodasLasPosiciones x) rec) 
	[[]] 
	where agregarEnTodasLasPosiciones j js = 
		[ (fst h)++[j]++(snd h)| h <- (partir js)]
	\end{minted}
\end{centrado}

\subsection{Ejercicio 11}

\begin{centrado}
	\begin{minted}[tabsize=2,breaklines]{haskell}
	partes :: [a] -> [[a]]
	partes = foldr (\x res -> res ++ (map (x:) res)) [[]]
	\end{minted}
\end{centrado}

\begin{centrado}
	\begin{minted}[tabsize=2,breaklines]{haskell}
	prefijos :: [a] -> [[a]]
	prefijos xs = [take i xs | i <- [0..(length xs)]]
	\end{minted}
\end{centrado}

\begin{centrado}
	\begin{minted}[tabsize=2,breaklines]{haskell}
	sublistas :: [a] -> [[a]]
	sublistas xs = [[]] ++ [ take j (drop i xs)  
		| i<-[0..(length xs)] , j<-[1..(length xs)-i]]
	\end{minted}
\end{centrado}


\subsection{Ejercicio 12}
\begin{centrado}
	\begin{minted}[tabsize=2,breaklines]{haskell}
sacarUna :: Eq a => a -> [a] -> [a]
sacarUna x = recr (\y ys rec -> if (x==y) then ys else y:rec) []
	\end{minted}
\end{centrado}

\mintinline{haskell}{recr}, nos permite escribir funciones recursivas cuyo paso recursivo no solo dependen del paso anterior, sino que tambien dependen de la cola de la lista. Mientras que \mintinline{haskell}{foldr} es el esquema recursivo de inducción estructural, es decir nos permite definir funciones que solo dependen del caso anterior.

En cuanto a la función \mintinline{haskell}{listasQueSuman} del ejercicio 6, vemos que el valor de esta función depende de todos los casos anteriores, por lo que se hacen tantas llamadas recursivas como casos anteriores halla. Evidentemente, ni \mintinline{haskell}{fold} y ni \mintinline{haskell}{recr} nos dan un mecanismo para hacer esto.

\subsection{Ejercicio 13}
\begin{centrado}
	\begin{minted}[breaklines, tabsize=2]{haskell}
genLista :: a -> (a -> a) -> Int -> [a]
genLista x f 0 = [x]
genLista x f n = x:(genLista (f x) f (n-1))
	\end{minted}
\end{centrado}

\begin{centrado}
	\begin{minted}[breaklines, tabsize=2]{haskell}
desdeHasta :: Int -> Int -> [Int]
desdeHasta x z = genLista x (+1) (z-x)
	\end{minted}
\end{centrado}

\subsection{Ejercicio 14}
\begin{centrado}
\begin{minted}[breaklines,tabsize=2]{haskell}
mapPares :: (a -> b -> c) -> [(a,b)] -> [c]
mapPares f = map (unCurry f) xs
\end{minted}
\end{centrado}
\begin{centrado}
	\begin{minted}[breaklines,tabsize=2]{haskell}
armarPares :: [a] -> [b] -> [(a,b)]
armarPares xs ys = 
	if ( (length xs) > (length ys) ) then 
		((foldr (\x rec-> \ys -> (x,head ys):(rec (tail ys)) ) (\ys -> []) xs) ys)
	else 
		((foldr (\y rec-> \xs -> (y,head xs):(rec (tail xs)) ) (\xs -> []) ys) xs)
	\end{minted}
\end{centrado}

\begin{centrado}
\begin{minted}[tabsize=2, breaklines]
mapDoble :: (a -> b -> c) -> [a] -> [b] -> [c]
mapDoble f xs ys = mapPares f (armarPares xs ys)
\end{minted}
\end{centrado}
%
%	
%\subsection{Ejercicio 15}
%	\begin{centrado}
%		\begin{minted}[breaklines,tabsize=2]{haskell}
%			sumaMat :: [[Int]] -> [[Int]] -> [[Int]]
%			sumaMat xss yss = map (\(xs,ys) -> mapDoble (+) xs ys) (armarPares xss yss)
%			
%			trasponer :: [[Int]] -> [[Int]]
%			trasponer xss = foldr1 (\xs rec -> mapDoble (:) xs rex) xss
%		\end{minted}
%	\end{centrado}
%
\subsection{Ejercicio 16}
\subsection{Ejercicio 17}

	\begin{centrado}
		\begin{minted}[breaklines,tabsize=2]{haskell}
			foldNat :: (a->a) -> a -> Integer -> a
			foldNat f b 0 = b
			foldNat f b n = f (foldNat f b (n-1))
			
			potencia :: Int -> Int -> Int
			potencia n e = foldNat (\i rec-> rec*n) (n) (e-1)
		\end{minted}
	\end{centrado}
\subsection{Ejercicio 18}
	\begin{centrado}
		\begin{minted}[breaklines,tabsize=2]{haskell}
type Conj a = (a->Bool)

vacio :: Conj a
vacio a = (\x -> True)

agregar :: Eq a => a -> Conj a -> Conj a
agregar x a = (\y -> (a y) || (y==x))

interseccion :: Conj a -> Conj a-> Conj a
interseccion a b = (\x -> (a x) && (b x))

union :: Conj a -> Conj a-> Conj a
union a b = (\x -> (a x) || (b x))

singleton :: Eq a => a -> Conj a
singleton x = (\y -> y==x)

map no se puede definir, porque no podemos hacer referencia a los elementos de la estructura si no los conocemos.
		\end{minted}
	\end{centrado}
	
\subsection{Ejercicio 19}
\subsection{Ejercicio 20}
\subsection{Ejercicio 21}
\subsection{Ejercicio 22}
\subsection{Ejercicio 23}
