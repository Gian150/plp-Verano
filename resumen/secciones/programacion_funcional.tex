
\section{Programación Funcional}
Los dos aspectos fundamentales de la programación son:
\begin{itemize}
	\item Transformación de la información.
	\item Interacción con el medio (cargar datos, interfaces gráficas, etc).
\end{itemize}
La programación funcional se concentra en el primer aspecto.

\paragraph{Valor} Entidad matemática abstracta con ciertas propiedades.

\subsubsection{Expresión} 

Secuencia de símbolos utilizada para denotar un valor. Hay dos tipos de expresiones:
\begin{itemize}
	\item \textbf{Atómicas ó formas formales}: Son las expresiones más simples y denotan un valor.
	\item \textbf{Compuestas}: Expresiones que se construyen combinando otras expresiones.
\end{itemize}

Puede haber expresiones incorrectas (mal formadas) debido a errores sintácticos (expresiones mal escritas) o a errores de tipo (expresiones que denotan operaciones sobre tipos incorrectos).

En funcional, computar significa tomar una expresión y reducirla hasta que sea atómica.

\paragraph{Transparencia referencial} El valor que denota una expresión solo depende de los símbolos que la constituyen. Esto nos permite indicar. Esto nos permite hacer uso de un programa sin considerar la necesidad de considerar los detalles de su ejecución y nos permite demostrar propiedades usando las propiedades de las subexpresiones y métodos  de deducción lógica.

\subsection{Tipos}
Son una forma de particionar el universo de valores de acuerdo a ciertas propiedades. Hay:
\begin{itemize}
	\item \textbf{Tipos básicos} (Int, Bool, Float) ó primitivos que son los que ya vienen definidos en el lenguaje por literales y representan valores 
	\item \textbf{Tipos compuestos} (pares, ) que son aquellos que se definen a partir de otros tipos.
\end{itemize}

Cada tipo de dato tiene asociado operaciones que no tienen significado para otros tipos.

A toda expresión bien formada se le puede asignar un tipo que sólo depende los componentes de la expresión (strong-typing). Dada una expresión, se puede deducir su tipo a partir de su constitución.

\subsubsection{Notación}  
\mintinline{haskell}{e :: A } se lee “la expresión \mintinline{haskell}{e} tiene tipo \mintinline{haskell}{A}” y significa que el valor denotado por \mintinline{haskell}{e} pertenece al conjunto de valores denotado por \mintinline{haskell}{A}.

\subsubsection{Propiedades deseables de un lenguaje funcional}
Se busca que un lenguaje le asigne un tipo de manera automática al mayor número posible de expresiones con sentido y que no le asigne ningún tipo al mayor número posible de expresiones mal formadas. Además, se busca que el tipo de la expresión se mantenga si es reducida.

Otra cosa a tener en cuenta, es que los tipos ofrecidos por el lenguaje deben ser descriptivos y razonablemente sencillos de leer.

\paragraph{Inferencia de tipos} Dada una expresión e determinar si tiene tipo o no y, si lo tiene, cuál es ese tipo según las reglas.

\paragraph{Chequeo de tipos} Dada una expresión tipable \mintinline{haskell}{e} y un tipo \mintinline{haskell}{A}, determinar si \mintinline{haskell}{e :: A} o no.

\subsection{Tipo Función}
Un programa en el paradigma funcional es una función descripta por un conjunto de ecuaciones (expresiones) que definen uno o más valores. Estas ecuaciones son evaluadas (reducidas) hasta llegar a una expresión atómica que nos indique el valor de las mismas.

\paragraph{Funciones} Las funciones son valores especiales que representan transformación de datos. En haskell el tipo de una función se escribe: \mintinline{haskell}{->}. Las funciones se aplican a elementos de un conjunto de entrada definido por el tipo de entrada de la función y devuelve un elemento del tipo de salida.

Al ser valores, las funciones pueden ser argumentos y resultados de otras funciones, pueden almacenarse y pueden ser estructuras de datos.

\paragraph{Funciones de alto orden} Son funciones que manipulan otras funciones.

\paragraph{Lenguaje Funcional Puro} Lenguaje de expresiones con transparencia referencial y funciones como valores, cuyo modelo de cómputo es la reducción realizada mediante el reemplazo de iguales por iguales.

\paragraph{Polimorfismo paramétrico} Cuando una función tiene un parámetro que puede ser instanciado de diferentes maneras en diferentes usos. Esta propiedad se da dentro de los sistemas de tipos.

Dada una expresión que puede ser tipada de infinitas maneras, el sistema puede asignarle un tipo que sea más general que todos ellos, y tal que en cada uso pueda transformarse en uno particular.

Hay funciones que a pesar de poseer polimorfismo paramétrico, no aceptan cualquier clase de tipo, sino que requieren que los tipos con las que son llamadas tengan ciertas propiedades. Por ejemplo, que tengan relaciones de igualdad (\mintinline{haskell}{Eq}), relación de order (\mintinline{haskell}{Ord}), que se comporten como números (\mintinline{haskell}{Num}) o que puedan ser mostrados en pantalla (\mintinline{haskell}{Show})

\subsubsection{Evaluación}
Por lo general, dependiendo del orden de evaluación del lenguaje, el tipo de evaluación se  clasifica en:

\paragraph{Evaluación Estricta} Si una parte de una expresión se indefine, entonces la expresión se indefine. La evaluación eager, en la que un en lenguaje computa una expresión apenas es definida, es de este tipo. 

\paragraph{Evaluación no Estricta} Puede pasar que una expresión esté definida a pesar de que alguna de sus partes se haya indefinido. La evaluación lazy, en la que un lenguaje solo computa una expresión cuando de esta depende el valor de otra expresión, es de este tipo.

Haskell usa evaluación lazy de izquierda a derecha, resolviendo primero las partes más externas de la expresión y luego, si es necesario, sus partes.

\paragraph{Currificación} Correspondencia entre cada función de múltiples parámetros y una de alto orden que retorna una función intermedia que completa el trabajo.
Por cada \textit{f} definida como:
\begin{centrado}
	\begin{minted}{haskell}
f :: (a,b) -> c
f (x,y) = e
	\end{minted}
\end{centrado} 
existe un función \textit{f'} tal que se puede escribir:
\begin{centrado}
	\begin{minted}{haskell}
f' :: a -> (b -> c)
(f' x) y = e
	\end{minted}
\end{centrado} 

La currificación nos da mayor expresividad y la posibilidad de realizar evaluación parcial. Además, nos permite tratar el código de manera más modular al momento de inferir tipos y transformar programas.

\paragraph{Evaluación parcial} Se evalúan las funciones parcialmente, lo que nos permite llamarlas con menos parámetros de los que necesitan. Esto nos devuelve una función con las expresiones asociadas a los valores pasados como parámetros y que toma como parámetros los parámetros faltantes de la función original.

\subsection{Inducción/Recursion}

La inducción es un mecanismo que nos permite definir conjuntos infinitos, probar propiedades sobre sus elementos y definir funciones recursivas sobre ellos con garantía de terminación.

\paragraph{Principio de extensionalidad:} Dadas dos expresiones A y B, si A y B denotan el mismo valor, entonces A puede ser remplazada por B y B por A sin que esto afecte al resultado de una equación.

\subsubsection{Inducción estructural}
Una definición inductiva de un conjunto $\rel$ consiste en dar condiciones de dos tipos:
\begin{itemize}
	\item reglas base ($z\in\rel$) que afirman que algún elemento simple $x$ pertenece a $\rel$
	\item reglas inductivas ($y_1\in\rel,\dots,y_n\in\rel\Rightarrow y\in\rel$) que afirman que un elemento compuesto $y$ pertenece a
	$\rel$ siempre que sus partes $y_1,\dots,y_n$ pertenezcan a $\rel$
	(e $y$ no satisface otra regla de las dadas)
\end{itemize}

y pedir que $\rel$ sea el menor conjunto (en sentido de
la inclusión) que satisfaga todas las reglas dadas.

\subsubsection{Funciones recursivas}
Sea \mintinline{haskell}{S} un conjunto inductivo, y \mintinline{haskell}{T} uno cualquiera. Una definición recursiva estructural de una función \mintinline{haskell}{f :: S -> T} es una definición de la siguiente forma:
\begin{itemize}
	\item Por cada elemento base \mintinline{haskell}{z}, el valor de \mintinline{haskell}{(f z)} se da directamente usando valores previamente definidos
	\item Por cada elemento inductivo \mintinline{haskell}{y}, con partes inductivas \mintinline{haskell}{y1}, ..., \mintinline{haskell}{yn}, el valor de \mintinline{haskell}{(f y)} se da usando valores previamente definidos y los valores \mintinline{haskell}{(f y1)}, ..., \mintinline{haskell}{(f yn)}.
\end{itemize}

\subsubsection{Principio de inducción}
Sea $S$ un conjunto inductivo, y sea $P$ una propiedad sobre los elementos de S. Si se cumple que:
\begin{itemize}
	\item para cada elemento $z\in S$ tal que $z$ cumple con una regla base, $P(z)$ es verdadero, y
	\item para cada elemento $y\in S$ construido en una regla inductiva utilizando los elementos \\ $y_1, ..., y_n$, si $P(y_1 ), ..., P(y_n)$ son verdaderos entonces $P(y)$ lo es
	
\end{itemize}

entonces $P(x)$ se cumple para todos los $x\in S$.

\subsection{Parametrización}
Dado un conjunto de funciones que se comportan de la misma manera buscamos encontrar alguna forma de crear una función que las genere automáticamente. 

\paragraph{Esquema de funciones} Dado un conjunto de funciones ``parecidas'', el esquema de estas funciones son los que no permiten parametrizar correctamente alguno de los parámetros.

La parametrización nos permitirá crear definiciones más concisas y modulares, reutilizar código y demostrar propiedades generales de manera más fácil.

\subsection{Tipos algebraicos}

\subsubsection{Definición de tipos}
Hay dos formas de definir un tipo de dato:
\begin{itemize}
	\item \textbf{De manera algebraica:} Establecemos qué \textit{forma} tendrá cada \textit{elemento} y damos un mecanismo único para inspeccionar cada elemento.
	\item \textbf{De manera abstracta:} Determinamos cuales serán las \textit{operaciones} que manipularán los elementos, \textbf{SIN} decir cuál será la forma exacta del tipo ni de las operaciones que definimos.
\end{itemize}

\subsubsection{Tipos algebraicos en Haskell}
Los definimos mediante \textbf{constantes} llamadas \textit{constructores} cuyos nombres comienzan con mayúscula. Los constructores no tienen asociada una regla de reducción y pueden tener argumentos.

Para implementarlos en Haskell, usamos la clausula \texttt{data} que introduce un nuevo tipo algebraico, los nombres de su constructores y sus argumentos.

\textbf{Ejemplos:}
\begin{centrado}
	\begin{minted}{haskell}
data Sensacion = Frio | Calor
data Shape = Circle Float | Rect Float Float
	\end{minted}
\end{centrado}

Los tipos algebraicos pueden tener argumentos. Esto nos permite definir tipos que contienen al conjunto de elementos de otro tipo más los elementos del tipo que se están definiendo.

\textbf{Ejemplo:}
\begin{centrado}
	\begin{minted}{haskell}
data Maybe = Nothing | Just a
	\end{minted}
\end{centrado}
\texttt{Maybe} tiene todos los elementos del tipo a con \texttt{Just} adelante más el elemento \textit{Nothing}

\vspace*{5mm}

Son considerados tipos algebraicos porque:
\begin{itemize}
	\item toda combinación válida de constructores y valores es elemento del tipo algebraico (y solo ellas lo son)
	\item y porque dos elementos de un tipo algebraico son iguales si y solo si están construidos utilizando los mismos constructores aplicados a los mismos valores.
\end{itemize}
Al principio de esta sección, dijimos que además de establecer la forma que tiene el tipo, debemos dar un mecanismo único de inspección. En Haskell, este mecanismo es el \textbf{Pattern Matching}.


\subsubsection{Pattern Matching}
El pattern matching es la búsqueda de patrones especiales (en nuestro caso, los constructores de nuestro tipo) dentro de una expresión en el lado izquierdo de una ecuación que, si tiene éxito, nos permita inspeccionar el valor de la misma.

Si el pattern matching resulta exitoso, entonces ligas las variables del patrón.

\subsubsection{Tipos especiales}
\paragraph{Tupla} Este tipo es un tipo algebraico con sintaxis especial. Una tupla es un estructura que posee varios elementos de distintos tipos. Por ejemplo: \mintinline{haskell}{(Float,Int)} es una tupla cuyo primer elemento es un \mintinline{haskell}{Float} y tiene como segundo elemento a un \mintinline{haskell}{Int}.

\paragraph{Maybe} El tipo \texttt{Maybe}, definido en el último ejemplo, nos permite expresar la posibilidad de que el resultado sea erróneo, sin necesidad de usar casos especiales. De esta forma, logramos evitar el uso de $\bot$ hasta que el programador lo decida, permitiendo controlar errores.

\paragraph{Either} El tipo \mintinline{haskell}{Either} representa la unión disjunta de dos conjuntos (los elementos de uno se identifican con \mintinline{haskell}{Left} y los del otro con \mintinline{haskell}{Right}. Sirve para mantener el tipado fuerte y poder devolver elementos de distintos tipos o para representar el origen de un valor.
\begin{centrado}
	\begin{minted}{haskell}
data Either = Left a | Right b
	\end{minted}
\end{centrado}

\subsubsection{Expresividad}
Los tipos algebraicos no pueden representar cualquier cosa, por ejemplo, los números racionales son pares de enteros (numerador, denominador) cuya igualdad puede no depender de los valores con los que fueron construidos o incluso pueden llegar a no ser validos. Esto es así porque no todo par de enteros es un número racional, por ejemplo el (1,0). 

Además recordemos que la igualdad de dos elementos de un tipo algebraico solo se da si estos fueron construidos exactamente de la misma forma. Si seguimos con el ejemplo de los racionales, sabemos que hay racionales iguales con distinto numerador y denominador como el (4,2) y el (2,1), sin embargo estos dos pares no podrían ser nunca iguales si fuesen tomados como un tipo algebraico.

\subsubsection{Clases de tipos algebraicos}

\paragraph{Enumerativos} Solo constructores sin argumentos.

\paragraph{Productos} Un único constructor con varios argumentos.

\paragraph{Sumas} Varios constructores con argumentos.

\paragraph{Recursivos} Utilizan el tipo definido como argumento.

\subsection{Tipos algebraicos recursivos}
Un tipo algebraico recursivo tiene al menos menos uno de los constructores con el tipo que se define como argumento y es la concreción, en Haskell, de un conjunto definido inductivamente.

Cada constructor define un caso de una definición inductiva de un conjunto. Si tiene al tipo definido como argumento, entonces es un caso inductivo, si no, es un caso base.

En estos caso, el pattern matching nos da una forma de realizar analizar los casos y de acceder a los elementos inductivos que forman a un elemento dado. Por esta razón, se pueden definir funciones recursivas.

A estos tipos, les damos un significado a través de funciones definidas recursivamente. Estas funciones manipulan simbólicamente al tipo. Sin embargo, estas manipulaciones, por si solas no tienen un significado, sino que el significado se lo dan las propiedades que dichas manipulaciones deben cumplir.

\paragraph{Enteros} Notación unaria para expresar tipos enteros.
\begin{centrado}
	\begin{minted}[breaklines]{haskell}
data N = Z | S N
	\end{minted}
\end{centrado}

\paragraph{Listas} Definición equivalente a las listas de Haskell
\begin{centrado}
	\begin{minted}[breaklines]{haskell}
data List a = Nil | Cons a (List a)
	\end{minted}
\end{centrado}

\paragraph{Árboles}
Un árbol es un tipo algebraico tal que al menos un elemento compuesto tiene dos componentes inductivas.

\begin{centrado}
	\begin{minted}[breaklines]{haskell}
data Arbol a = Hoja a | Nodo a (Arbol a) (Arbol a)
	\end{minted}
\end{centrado}

\subsection{Esquemas de recursión} \label{sec:funcional.sub:esquemas_recursion}
Cuando tenemos un conjunto de funciones que manipulan ciertas estructuras de manera similar, podemos abstraer este comportamiento en funciones de alto orden que nos facilitarán su escritura.

A continuación, veremos unos ejemplos de esquemas sobre listas: 
\subsubsection{Map}
Dada una lista \mintinline{haskell}{l}, aplica una función \mintinline{haskell}{f} a cada elemento de \mintinline{haskell}{l}.
\begin{centrado}
	\begin{minted}{haskell}
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = (f x) : (map f xs)
	\end{minted}
\end{centrado} 

\textbf{Ejemplo:}
\begin{centrado}
	\begin{minted}{haskell}
doble x = x + x
dobleL = map doble  
	\end{minted}
\end{centrado} 

\mintinline{haskell}{dobleL} calcula el doble de cada elemento de una lista.

\subsubsection{Filter}
Dada una lista \mintinline{haskell}{l} y un predicado \mintinline{haskell}{p}, selecciona todos los elementos de \mintinline{haskell}{l} que cumplen \mintinline{haskell}{p}.

\begin{centrado}
	\begin{minted}{haskell}
filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter p (x:xs) | (p x)     = x : (filter p xs)
                | otherwise = filter p xs  
	\end{minted}
\end{centrado}

\textbf{Ejemplo}
\begin{centrado}
	\begin{minted}{haskell}
masQueCero = filter (>0)
	\end{minted}
\end{centrado}

\mintinline{haskell}{masQueCero} se queda con todos los elementos mayores de una lista

\subsubsection{Fold}
La función {fold} es la función que expresa el patrón de recursión estructural sobre listas como función de alto orden. Dada una lista \mintinline{haskell}{l} y una función \mintinline{haskell}{f} que denota un valor que depende de todos los elementos de la lista \mintinline{haskell}{l} y un valor inicial \mintinline{haskell}{z}, aplica y combina las soluciones parciales obtenidas por \mintinline{haskell}{f} de manera  ``iterativa''. 
Hay dos tipos de fold: \mintinline{haskell}{foldr} (acumula desde la derecha) y \mintinline{haskell}{foldl} (acumula desde la izquierda).

\begin{centrado}
	\begin{minted}{haskell}
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr _ z [] = z
foldr f z (x:xs) = f x (foldr f z xs)
		
		
foldl :: (b -> a -> b) -> b -> [a] -> b
foldl f z [] = z
foldl f z (x : xs) = foldl f (f z x) xs
	\end{minted}
\end{centrado}

\textbf{Ejemplos}

\begin{centrado}
	\begin{minted}{haskell}
map f = foldr (\x rec -> (f x): rec) []
filter p = foldr (\x rec -> if (p x) then x:rec else rec) []
	\end{minted}
\end{centrado}


\subsubsection{Recursión primitiva}
Recordemos de Logica y Computabilidad: una función h es recursiva primitiva si \textit{h} es de la forma:

\begin{align*}
	h(x_1,\dots,x_n,0) &= f(x_1,\dots,x_n) \\
	h(x_1,\dots,x_n,t+1) &= g(h(x_1,\dots,x_n, t),x_1,\dots, x_n, t) \\
\end{align*}

Es decir, el caso recursivo de \textit{h} no solo depende de la descomposición de sus parámetros, sino que, además, depende de sus parámetros.

En Haskell, podemos definir una función que dada una lista \mintinline{haskell}{l}, un caso base \mintinline{haskell}{z} y un caso recursivo primitivo \mintinline{haskell}{f}, aplique la definición de \mintinline{haskell}{z} y \mintinline{haskell}{f} a la lista:
\begin{centrado}
	\begin{minted}{haskell}
recr :: b -> (a -> [a] -> b -> b) -> [a] -> b
recr z _ []= z
recr z f (x:xs) = f x xs (recr z f xs)
	\end{minted}
\end{centrado}

En listas, este tipo de esquemas es difícil de ver. Como ejemplo, escibimos la función \mintinline{haskell}{insertar} de una lista con recursión primitiva:
\begin{centrado}
	\begin{minted}{haskell}
-- Insert con pattern matching
insert :: a -> [a] -> [a]
insert x [] = [x]
insert x (y:ys) = if x<y then (x:y:ys) else (y:insert x ys)
		
-- Insert con recursión primitiva
insert x = recr [x] (\y ys zs -> if x<y then (x:y:ys) else (y:zs))
	\end{minted}
\end{centrado}

En el segundo caso, \mintinline{haskell}{insert} es una función que agrega el elemento \mintinline{haskell}{x} a una lista \mintinline{haskell}{xs} que se le pase como parámetro.

\subsubsection{Divide \& Conquer}
La técnica de Divide \& Conquer consiste en dividir un problema en problemas más fáciles de resolver y luego, combinando los resultados parciales, lograr
obtener un resultado general. En este caso, \mintinline{haskell}{DivideConquer} es un tipo de función, es decir define una familia de funciones, que toman como parámetro 4 funciones y un elemento de tipo \texttt{a} y devuelve un elemento de tipo \texttt{b}:
\begin{centrado}
	\begin{minted}[breaklines]{haskell}
type DivideConquer a b  = (a -> Bool) -> (a -> b) -> (a -> [a]) 
    -> ([b] -> b) -> a -> b                         
	\end{minted}
\end{centrado}
Las funciones que toma como parámetro son:
\begin{itemize}
	\item \mintinline{haskell}{esTrivial :: a -> Bool} que devuelve verdadero si elemento de tipo \texttt{a} es el caso base del problema.
	\item \mintinline{haskell}{resolver :: a -> b} que resuelve el problema cuando el elemento de tipo \texttt{a} es el caso trivial
	\item \mintinline{haskell}{repartir :: a -> [a]} que divide al elemento de tipo \texttt{a} en la cantidad de subproblemas necesarios para resolver el problema.
	\item \mintinline{haskell}{combinar :: [b] -> b} que resuelve todos los subproblemas obtenidos por \texttt{repartir} y combina sus soluciones para obtener el resultado final.
\end{itemize}

\textbf{Ejemplo}

Vamos a definir el Divide \& Conquer para listas:
\begin{centrado}
	\begin{minted}[breaklines]{haskell}
divideConquerListas :: DivideConquer [a] b
-- Esto significa que DivideConquerLista es de tipo 
-- ([a] -> Bool) -> ([a] -> b) -> ([a] -> [[a]]) -> ([b] -> b)
-- -> [a] -> b
		
divideConquerListas esTrivial resolver repartir combinar l =
if (esTrivial l) then resolver l
else combinar (map dc (repartir l))
where dc = divideConquerListas esTrivial resolver repartir combinar	
	\end{minted}
\end{centrado}


\paragraph{Otros esquemas de recursión} Los esquemas de recursión que nombramos, no son los únicos que existen y además, pueden ser definidos para otros tipos recursivos, no solo para listas.

\subsubsection{La función fold y como definirla}
Todo tipo algebraico tiene asociado un patrón de inducción estructural. En particular, dado un tipo algebraico recursivo \mintinline{haskell}{T}, podemos definir la función \mintinline{haskell}{foldrT:: * -> a} donde * son los parámetros de la función. A continuación damos algunas propiedades que debe cumplir para asegurarnos de la definimos correctamente:
\begin{itemize}
	\item Por cada constructor recursivo debe tomar una función que tome como parámetros a cada elemento del constructor que no sea del tipo \texttt{T} y un parámetro de tipo \texttt{a} por cada elemento del tipo \texttt{T}  del constructor. Esta función devuelve un elemento del tipo \texttt{a} y es la que resolverá recursivamente el caso planteado usando la segunda clase de parámetros.
	\item Por cada constructor base de \texttt{T} debe tomar un parámetro de tipo \text{a} que será el elemento devuelto por la función si cae en alguno de dichos casos.
	\item Por último, si la función está bien implementada, si remplazamos cada parámetro por el contructor correspondiente que tiene asignado, la función resultante debería ser la función identidad del tipo \texttt{T}.
\end{itemize}


Al momento de definir \texttt{fold} ayuda mucho plantear el esquema de recursión del tipo.